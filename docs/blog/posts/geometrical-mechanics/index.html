<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Yuxi on the Wired</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../img/favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Yuxi on the Wired">
<meta property="og:description" content="Personal website of Yuxi Liu">
<meta property="og:image" content="https://yuxi-liu-wired.github.io/blog/posts/geometrical-mechanics/img/blog icon.jpg">
<meta property="og:site_name" content="Yuxi on the Wired">
<meta name="twitter:title" content="Yuxi on the Wired">
<meta name="twitter:description" content="Personal website of Yuxi Liu">
<meta name="twitter:image" content="https://yuxi-liu-wired.github.io/blog/posts/geometrical-mechanics/img/blog icon.jpg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../img/favicon.ico" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Yuxi on the Wired</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects/index.qmd"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about/index.qmd"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://bair.berkeley.edu/"> <i class="bi bi-folder-symlink" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:yuxi.liu.1995@gmail.com"> <i class="bi bi-envelope" role="img" aria-label="email">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-geometry-of-physical-states" id="toc-the-geometry-of-physical-states" class="nav-link active" data-scroll-target="#the-geometry-of-physical-states">The geometry of physical states</a>
  <ul class="collapse">
  <li><a href="#state-space-configuration-space-phase-space-and-coordinate-systems" id="toc-state-space-configuration-space-phase-space-and-coordinate-systems" class="nav-link" data-scroll-target="#state-space-configuration-space-phase-space-and-coordinate-systems">State space, configuration space, phase space, and coordinate systems</a></li>
  <li><a href="#lagrangian-and-hamiltonian" id="toc-lagrangian-and-hamiltonian" class="nav-link" data-scroll-target="#lagrangian-and-hamiltonian">Lagrangian and Hamiltonian</a></li>
  <li><a href="#point-transformation" id="toc-point-transformation" class="nav-link" data-scroll-target="#point-transformation">Point transformation</a></li>
  <li><a href="#canonical-transformation" id="toc-canonical-transformation" class="nav-link" data-scroll-target="#canonical-transformation">Canonical transformation</a></li>
  </ul></li>
  <li><a href="#the-geometry-of-phase-space" id="toc-the-geometry-of-phase-space" class="nav-link" data-scroll-target="#the-geometry-of-phase-space">The geometry of phase space</a>
  <ul class="collapse">
  <li><a href="#poisson-bracket" id="toc-poisson-bracket" class="nav-link" data-scroll-target="#poisson-bracket">Poisson bracket</a></li>
  <li><a href="#liouvilles-theorem" id="toc-liouvilles-theorem" class="nav-link" data-scroll-target="#liouvilles-theorem">Liouville’s theorem</a></li>
  <li><a href="#the-interpretation-of-phase-space-geometry" id="toc-the-interpretation-of-phase-space-geometry" class="nav-link" data-scroll-target="#the-interpretation-of-phase-space-geometry">The interpretation of phase space geometry</a></li>
  </ul></li>
  <li><a href="#all-the-variational-principles-of-physics-that-youre-likely-to-ever-see" id="toc-all-the-variational-principles-of-physics-that-youre-likely-to-ever-see" class="nav-link" data-scroll-target="#all-the-variational-principles-of-physics-that-youre-likely-to-ever-see">All the variational principles of physics that you’re likely to ever see</a>
  <ul class="collapse">
  <li><a href="#hamiltons-principle-and-modified-hamiltons-principle" id="toc-hamiltons-principle-and-modified-hamiltons-principle" class="nav-link" data-scroll-target="#hamiltons-principle-and-modified-hamiltons-principle">Hamilton’s principle and modified Hamilton’s principle</a></li>
  <li><a href="#maupertuis-principle" id="toc-maupertuis-principle" class="nav-link" data-scroll-target="#maupertuis-principle">Maupertuis’ principle</a></li>
  </ul></li>
  <li><a href="#canonical-transformations" id="toc-canonical-transformations" class="nav-link" data-scroll-target="#canonical-transformations">Canonical transformations</a>
  <ul class="collapse">
  <li><a href="#generating-functions" id="toc-generating-functions" class="nav-link" data-scroll-target="#generating-functions">Generating functions</a></li>
  <li><a href="#generating-functions-for-hamiltonians" id="toc-generating-functions-for-hamiltonians" class="nav-link" data-scroll-target="#generating-functions-for-hamiltonians">Generating functions for Hamiltonians</a></li>
  <li><a href="#coordinate-based-canonical-transforms" id="toc-coordinate-based-canonical-transforms" class="nav-link" data-scroll-target="#coordinate-based-canonical-transforms">Coordinate-based canonical transforms</a></li>
  <li><a href="#examples-of-canonical-transforms" id="toc-examples-of-canonical-transforms" class="nav-link" data-scroll-target="#examples-of-canonical-transforms">Examples of canonical transforms</a></li>
  <li><a href="#simple-harmonic-oscillator" id="toc-simple-harmonic-oscillator" class="nav-link" data-scroll-target="#simple-harmonic-oscillator">Simple harmonic oscillator</a></li>
  <li><a href="#canonical-transforms-in-general" id="toc-canonical-transforms-in-general" class="nav-link" data-scroll-target="#canonical-transforms-in-general">Canonical transforms, in general</a></li>
  <li><a href="#poisson-brackets-are-preserved-by-canonical-transforms" id="toc-poisson-brackets-are-preserved-by-canonical-transforms" class="nav-link" data-scroll-target="#poisson-brackets-are-preserved-by-canonical-transforms">Poisson brackets are preserved by canonical transforms</a></li>
  <li><a href="#interpretation-of-canonical-transforms" id="toc-interpretation-of-canonical-transforms" class="nav-link" data-scroll-target="#interpretation-of-canonical-transforms">Interpretation of canonical transforms</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">




<section id="the-geometry-of-physical-states" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-geometry-of-physical-states">The geometry of physical states</h2>
<p>Consider a particle in a field, in polar coordinates. We have</p>
<p><span class="math display">\[L = \frac 12 m (\dot r^2 + r^2 \dot \theta^2) - V(r, \theta)\]</span></p>
<p>Now suppose we want to use a rotating frame at angular velocity <span class="math inline">\(+\Omega\)</span>, then we can use the change of variables by <span class="math inline">\(\theta = \phi + \Omega t\)</span>, plug into the Euler–Lagrange equations, and obtain</p>
<p><span class="math display">\[\begin{cases}
m\ddot r = mr\dot\phi^2 -\partial_r V(r, \phi + \Omega t)  + mr\Omega^2 + 2m(r\dot \phi)\Omega \\
m(r\ddot\phi + 2\dot r\dot \phi) = -\frac 1r \partial_\theta(r, \phi+ \Omega t) - 2m\dot r\Omega
\end{cases}\]</span></p>
<p>In the above procedure, we simply performed a change of variables, then plugged into the Euler–Lagrange equations without comment, but are we allowed to do that? Yes, but there are conditions – the change of variables must not depend on velocity.</p>
<section id="state-space-configuration-space-phase-space-and-coordinate-systems" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="state-space-configuration-space-phase-space-and-coordinate-systems">State space, configuration space, phase space, and coordinate systems</h3>
<p>At this point, it is important to be as explicit as possible, carefully distinguishing between often confused concepts:</p>
<ul>
<li><strong>physical state</strong>: An intuitive concept that cannot be made more precise than say "this is what physicists study", much like how a geometric point cannot be made more precise than say "this is what geometers study".</li>
<li><strong>same</strong>: As in most modern mathematics, two things are "the same" when they are really just "equivalent" or "not distinguished in use". For example, there is really just one <span class="math inline">\(\R\)</span>, but we can have as many 1-dimensional vector spaces as we want, and they are all equivalent to <span class="math inline">\(\R\)</span>, though not literally the same as it (if they were, then we wouldn’t have as many vector spaces as we want!).</li>
<li><strong>(n-dimensional smooth) manifold</strong> <span class="math inline">\(\mathcal M\)</span>: a space that is locally the same as <span class="math inline">\(\R^n\)</span>. More precisely, at every point <span class="math inline">\(x\in \mathcal M\)</span>, there exists a coordinate system around <span class="math inline">\(x\)</span>.</li>
<li><strong>coordinate system</strong> of a manifold <span class="math inline">\(\mathcal M\)</span>: a diffeomorphism from an open subset of <span class="math inline">\(\mathcal M\)</span> to an open subset of <span class="math inline">\(\R^n\)</span>.</li>
<li><strong>diffeomorphism</strong>: a smooth, one-to-one function between two smooth spaces. (What is a smooth space? ... it’s a space smooth enough to do calculus in. Making it more precise would be too much of a detour.)</li>
<li><strong>state space</strong> <span class="math inline">\(\mathcal S\)</span>: the manifold of distinct physical states. Every point <span class="math inline">\(x\in \mathcal S\)</span> is a particular state that the system can assume. The manifold is built such that close-by points on the manifold are close-by physical states. That is, the topology of the state space (a precisely defined mathematical concept) is an exact representation of the topology of physical states (an intuitive concept that cannot be made more precise than that).</li>
<li><strong>tangent space</strong> <span class="math inline">\(\mathcal T_x\mathcal S\)</span> of a point <span class="math inline">\(x\in \mathcal S\)</span>: The vector space of all possible velocities at that state. It has dimension <span class="math inline">\(n\)</span>, and is thus isomorphic to <span class="math inline">\(\R^n\)</span> as a vector space. However, it is not <em>literally the same</em> as <span class="math inline">\(\R^n\)</span>.</li>
<li><strong>cotangent space</strong> <span class="math inline">\(\mathcal T_x^\ast\mathcal S\)</span> of a point <span class="math inline">\(x\in \mathcal S\)</span>: The vector space of all possible momenta at that state. From the abstract perspective, a momentum is nothing more than a linear map of type <span class="math inline">\(p: \mathcal T_x\mathcal S \to \R\)</span>. That is, the only way to really "use" a momentum is to combine it with a velocity, mutually annihilating both of them and leaving behind nothing but a little real number representing the energy. It has dimension <span class="math inline">\(n\)</span>, and is thus isomorphic to <span class="math inline">\(\R^n\)</span> as a vector space. However, it is not <em>literally the same</em> as <span class="math inline">\(\R^n\)</span>. Neither is it literally the same as <span class="math inline">\(\mathcal T_x\mathcal S\)</span>.</li>
<li><strong>configuration space</strong> <span class="math inline">\(\mathcal C = \mathcal T\mathcal S\)</span>: The tangent bundle of state space. That is, at each <span class="math inline">\(x\in \mathcal S\)</span>, we "glue" the space of velocities <span class="math inline">\(\mathcal T_x \mathcal S\)</span> to the point. The totality of <span class="math inline">\(\mathcal C\)</span> with all its <span class="math inline">\(\mathcal T_x \mathcal S\)</span> is the configuration space.</li>
<li><strong>phase space</strong> <span class="math inline">\(\mathcal P = \mathcal T^\ast\mathcal S\)</span>: The cotangent bundle of state space. That is, at each point <span class="math inline">\(x\in \mathcal S\)</span>, we attach the space of momenta <span class="math inline">\(\mathcal T_x^\ast\mathcal S\)</span>.</li>
</ul>
<p>Do not worry if the words do not make much sense. The example will make it clear.</p>
<p>For concreteness, consider a pendulum-cart system, shown in Figure <a href="#fig:cart_pendulum" data-reference-type="ref" data-reference="fig:cart_pendulum">4</a>. It is clear that its state space is shaped like a cylinder: one circle for the angle of the pendulum, and one line being the location of the cart.</p>
<p>More examples are shown in Table <a href="#table:state-and-config-spaces" data-reference-type="ref" data-reference="table:state-and-config-spaces">2</a>. Most of them are obvious, except the one about particle on a sphere.</p>
<p>It’s clear that its state space is <span class="math inline">\(\mathbb S^2\)</span>. However, that is not equivalent to the torus <span class="math inline">\(\mathbb S^1 \times \mathbb S^1\)</span>. There is simply no way to split the sphere into a direct product of two circles (as a casual comparison between a donut and a ball can verify).</p>
<p>Furthermore, its configuration space <span class="math inline">\(\mathcal\mathbb S^2\)</span> is not equivalent to <span class="math inline">\(\R^2 \times \mathbb S^2\)</span>. To prove that, we invoke the hairy ball theorem: there is no smooth and everywhere nonzero vector field on <span class="math inline">\(\mathbb S^2\)</span>. Now, if it were equivalent to <span class="math inline">\(\R^2 \times \mathbb S^2\)</span>, then there is an obvious smooth and everywhere nonzero vector field: <span class="math inline">\(x \mapsto ((1, 0), x)\)</span>.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/cart_pendulum.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption class="margin-caption">The pendulum-cart system.</figcaption>
</figure>
</div>
<div id="table:state-and-config-spaces">
<table class="table">
<caption>Some physical systems and their state and configuration spaces. Note that the state spaces are not <em>literally</em> the same as the ones shown in the table, merely equivalent (by a diffeomorphism).</caption>
<thead>
<tr class="header">
<th style="text-align: left;">physical system</th>
<th style="text-align: left;">state space</th>
<th style="text-align: left;">configuration space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">particle in 3D space</td>
<td style="text-align: left;"><span class="math inline">\(\R^3\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\R^6\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">pendulum</td>
<td style="text-align: left;">circle <span class="math inline">\(\mathbb S^1\)</span></td>
<td style="text-align: left;">cylinder <span class="math inline">\(\R^1 \times \mathbb S^1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">double pendulum</td>
<td style="text-align: left;">torus <span class="math inline">\(\mathbb S^1 \times \mathbb S^1\)</span></td>
<td style="text-align: left;">cylinder-squared <span class="math inline">\(\R^2 \times \mathbb S^1 \times \mathbb S^1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">pendulum-cart</td>
<td style="text-align: left;">cylinder <span class="math inline">\(\R^1 \times \mathbb S^1\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\R^3 \times \mathbb S^1 \times \mathbb S^1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">particle on a sphere</td>
<td style="text-align: left;">sphere <span class="math inline">\(\mathbb S^2\)</span></td>
<td style="text-align: left;">tangent bundle of sphere <span class="math inline">\(\mathcal T\mathbb S^2\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>: Some physical systems and their state and configuration spaces. Note that the state spaces are not <em>literally</em> the same as the ones shown in the table, merely equivalent (by a diffeomorphism).</p>
</section>
<section id="lagrangian-and-hamiltonian" class="level3">
<h3 class="anchored" data-anchor-id="lagrangian-and-hamiltonian">Lagrangian and Hamiltonian</h3>
<p>With the above formalism, we can precisely define more concepts</p>
<ul>
<li><p><strong>trajectory</strong>, or <strong>path</strong>, in a manifold <span class="math inline">\(\mathcal M\)</span>: a function of type <span class="math inline">\(\gamma: [t_0, t] \to \mathcal M\)</span>.</p></li>
<li><p><strong>Lagrangian</strong> of a physical system with state manifold <span class="math inline">\(\mathcal S\)</span>: a function of type</p></li>
</ul>
<p><span class="math display">\[\mathcal L: \R \times \mathcal T\mathcal S \to \R.\]</span></p>
<p>That is, it is a time-varying field on configuration space.</p>
<ul>
<li><strong>Hamiltonian</strong> of a physical system with state manifold <span class="math inline">\(\mathcal S\)</span>: a function of type</li>
</ul>
<p><span class="math display">\[\mathcal H: \R \times \mathcal T^\ast \mathcal S \to \R.\]</span></p>
<p>That is, it is a time-varying field on phase space.</p>
<ul>
<li><strong>action of a path</strong></li>
</ul>
<p><span class="math display">\[S(\gamma) = \int_{t_0}^t \mathcal L(\tau, \gamma(\tau), \dot \gamma(\tau))d\tau.\]</span></p>
<p>Now, the convex duality between Lagrangian and Hamiltonian transfers with almost no change in notation:</p>
<p><span class="math display">\[\begin{cases}
\mathcal L(t, q, v) = \max_{p\in \mathcal T_q^\ast \mathcal S} (\langle p, v\rangle - \mathcal H(t, q, p)) \\
\mathcal H(t, q, p) = \max_{v\in \mathcal T_q \mathcal S} (\langle p, v\rangle - \mathcal L(t, q, v))
\end{cases}
\]</span></p>
<p><span class="math display">\[
\begin{cases}
p^\ast(t, q, v) = \mathop{\mathrm{arg\,max}}_{p\in \mathcal T_q^\ast \mathcal S} (\langle p, v\rangle - \mathcal H(t, q, p)) \\
v^\ast(t, q, p) = \mathop{\mathrm{arg\,max}}_{v\in \mathcal T_q \mathcal S} (\langle p, v\rangle - \mathcal L(t, q, v))
\end{cases}
\]</span></p>
<p>The economic argument almost goes through without problem, but we need to be careful with some notations. In particular, we take another look at gradients. What does it mean to write <span class="math inline">\(\nabla_v \mathcal L(t, q, v)\)</span>? The defining property is</p>
<p><span class="math display">\[\mathcal L(t, q, v + u\tau) = \mathcal L(t, q, v) + \lra{\nabla_v \mathcal L(t, q, v), u} \tau + O(\tau^2)\]</span></p>
<p>which implies the following operational definition:</p>
<p><span class="math display">\[\nabla_v \mathcal L(t, q, v) := u \mapsto \lim_{\tau \to 0} \frac 1\tau (\mathcal L(t, q, v + u\tau) - \mathcal L(t, q, v))\]</span></p>
<p>This definition makes it clear that <span class="math inline">\(\nabla_v \mathcal L(t, q, v)\)</span> is a function of type <span class="math inline">\(\mathcal T_q \mathcal S \to\R\)</span>, thus it is an element of <span class="math inline">\(\mathcal T_q^\ast \mathcal S\)</span>. Similarly, <span class="math inline">\(\nabla_p \mathcal H(t, q, p)\)</span> is an element of <span class="math inline">\(\mathcal T_q \mathcal S\)</span>. Succinctly, <span class="math inline">\(\nabla_q \mathcal L, \nabla_v \mathcal L, \nabla_q \mathcal H\)</span> are covector fields (like momentum), and <span class="math inline">\(\nabla_p \mathcal H\)</span> is a vector field (like velocity).</p>
<p>With these, the types of every equation come out correctly again:</p>
<p><span class="math display">\[\begin{cases}
v = \nabla_p \mathcal H(t, q, p^\ast(t, q, v))\\
p = \nabla_v \mathcal L(t, q, v^\ast(t, q, p))
\end{cases},
\frac{d}{dt}(\nabla_v \mathcal L) = \nabla_q \mathcal L,\quad
\begin{cases}
\dot p = -\nabla_q \mathcal H \\
\dot q = -\nabla_p \mathcal H
\end{cases}\]</span></p>
<p>Let’s call these the <strong>coordinate-free</strong> equations, to be contrasted with the <strong>coordinate-based</strong> equations, to be defined below.</p>
</section>
<section id="point-transformation" class="level3">
<h3 class="anchored" data-anchor-id="point-transformation">Point transformation</h3>
<p>Manifolds are geometrically pristine, but you can’t calculate numerically with them unless you lay down coordinate systems over them. Concretely, consider a state space <span class="math inline">\(\mathcal S\)</span>. We take an open subset <span class="math inline">\(U\)</span> of it, and define a coordinate system (with a possible dependence on time):</p>
<p><span class="math display">\[(q_1, ..., q_N): \R \times U \to \R^N\]</span></p>
<p>This coordinate system then induces a coordinate system over the configuration space:</p>
<p><span class="math display">\[(q_1, ..., q_N; v_1, ..., v_N): \R \times \mathcal T U \to \R^N \times \R^N\]</span></p>
<p>Now consider a different coordinate system</p>
<p><span class="math display">\[(Q_1, ..., Q_N): \R \times U \to \R^N\]</span></p>
<p>and suppose they are related by a function <span class="math inline">\(f: \R \times \R^N \to \R^N\)</span> such that</p>
<p><span class="math display">\[q(t, x) = f(t, Q(t, x))\]</span></p>
<p>This is then a <strong>point transformation</strong> of the coordinate system.</p>
<p>The point transformation induces a transformation of the velocities, too. To find the transformation of velocities, consider a path <span class="math inline">\(\gamma: \R \to \mathcal S\)</span>. Its velocity at time <span class="math inline">\(t\)</span> is <span class="math inline">\(\dot \gamma(t) \in \mathcal T_{\gamma(t)}\mathcal S\)</span>, a vector that looks like it <em>literally</em> lives in <span class="math inline">\(\R^N\)</span>, but is not. It is not a native of <span class="math inline">\(\R^N\)</span>, but thanks to the <span class="math inline">\(q\)</span>-coordinate system, it is <em>represented</em> by the <span class="math inline">\(\R^N\)</span>-vector</p>
<p><span class="math display">\[\frac{d}{dt} q(t, \gamma(t)) \in \R^N\]</span></p>
<p>Now plug in <span class="math inline">\(q(t, x) = f(t, Q(t, x))\)</span>, to find a relationship between the representation of <span class="math inline">\(\dot \gamma(t)\)</span> in <span class="math inline">\(q\)</span>-coordinate system and <span class="math inline">\(Q\)</span>-coordinate system:</p>
<p><span class="math display">\[\frac{d}{dt} q(t, \gamma(t)) = \frac{d}{dt} f(t, Q(t, \gamma(t))) = \partial_t f(t, Q(t, \gamma(t))) + \frac{\partial f}{\partial Q} \frac{d}{dt}Q(t, \gamma(t))\]</span></p>
<p>More succinctly, we have the following transformation from <span class="math inline">\((t, Q, V)\)</span> to <span class="math inline">\((t, q, v)\)</span>:</p>
<p><span class="math display">\[\begin{cases}
q = f(t, Q) \\
v= \partial_t f(t, Q) + \frac{\partial f}{\partial Q}(t, Q) V
\end{cases}\]</span></p>
<p><em>A note on matrix algebra: Conventionally, vectors are written as column-matrices, that is, <span class="math inline">\(q, v, Q, V\)</span> are written as <span class="math inline">\(N\times 1\)</span> matrices. Correspondingly, gradients, being </em>covectors<em>, are written as row-matrices, that is, <span class="math inline">\(\nabla_q l, \nabla_v l, \nabla_Q L, \nabla_V L\)</span>, are written as <span class="math inline">\(1 \times N\)</span> matrices. Finally, gradients of vector-valued functions, like <span class="math inline">\(\frac{\partial f}{\partial Q}\)</span>, are <span class="math inline">\(N\times N\)</span> matrices, with each row being a gradient of one vector coordinate. This convention makes everything come out cleanly, with no need to take the transpose of anything.</em></p>
<p>The point transformation also induces a transformation of the Lagrangians. While the Lagrangian itself is a function <span class="math inline">\(\mathcal L\)</span> of type <span class="math inline">\(\R \times \mathcal T \mathcal S \to \R\)</span>, the Lagrangians <span class="math inline">\(L(t, Q, V), l(t, q, v)\)</span> are functions of type <span class="math inline">\(\R \times \R^N \times \R^N \to \R\)</span>. Both <span class="math inline">\(L, l\)</span> are induced from <span class="math inline">\(\mathcal L\)</span> by the choice of coordinates. We have</p>
<p><span class="math display">\[\mathcal(t, x, u) = L(t, Q(t, x), V(t, x, u)) = l(t, q(t, x), v(t, x, u))\]</span></p>
<p>and plug in <span class="math inline">\(q(t, x) = f(t, Q(t, x)), v = \partial_t f(t, Q) + \frac{\partial f}{\partial Q}(t, Q) V\)</span>, we have</p>
<p><span class="math display">\[l\left(t, f(t, Q), \partial_t f(t, Q)  + \frac{\partial f}{\partial Q}(t, Q) V\right) = L(t, Q, V)\]</span></p>
<p>Brute computation shows that</p>
<p><span class="math display">\[\frac{d}{dt}(\nabla_V L) - \nabla_Q L = \left(\frac{d}{dt}(\nabla_v l) - \nabla_q l\right)\frac{\partial f}{\partial Q}\]</span></p>
<p>implying that the coordinate-based Euler–Lagrange equation is true in <span class="math inline">\((Q, V)\)</span> coordinates iff it is true in <span class="math inline">\((q, v)\)</span> coordinates.</p>
<p>What, in the final analysis, is a point transformation? It is nothing more than changing a time-varying coordinate system on the state space. Since our derivation of the coordinate-based Euler–Lagrange equations required no special property of the coordinate system, it must be preserved by point transformations. All the above verification was really nothing but "ceremonial".</p>
<p>In more detail: we know that the coordinate-free EL equations are true, which implies that the <span class="math inline">\(q\)</span>-coordinate-based EL equations and the <span class="math inline">\(Q\)</span>-coordinate-based EL equations are both true (since they are merely two coordinate-based representations on the coordinate-free equation). No <span class="math inline">\(Q\)</span>-to-<span class="math inline">\(q\)</span> translation is necessary!</p>
<p>What, then, is the phrase "point transformation" supposed to be contrasted with? It is contrasted with more general coordinate transforms that also depend on velocities, as <span class="math inline">\(q = f(t, Q, V)\)</span>. From the perspective given here, the contrast is really between "state space coordinate systems" and "configuration space coordinate systems". Whereas state space coordinate system is first defined as some</p>
<p><span class="math display">\[(q_1, ..., q_N): \R \times U \to \R^N\]</span></p>
<p>and that is then <em>extended</em> to <span class="math inline">\((q_1, ..., q_N; v_1, ..., v_N): \R \times \mathcal T U \to \R^N \times \R^N\)</span>, a configuration space coordinate system defines "all at once" a complete coordinate system</p>
<p><span class="math display">\[(q_1, ..., q_N; v_1, ..., v_N): \R \times \mathcal T U \to \R^N \times \R^N\]</span></p>
<p>It is no wonder that such overly general coordinate systems do not have nice properties, and do not satisfy the coordinate-based Euler–Lagrange equations.</p>
</section>
<section id="canonical-transformation" class="level3">
<h3 class="anchored" data-anchor-id="canonical-transformation">Canonical transformation</h3>
<p>Before writing this chapter, try going through <span class="citation" data-cites="bohnStudentGuideAnalytical2018">(<a href="#ref-bohnStudentGuideAnalytical2018" role="doc-biblioref">Bohn 2018, chap. 7</a>)</span>.</p>
<p>Whereas for the Lagrangian <span class="math inline">\(\mathcal L\)</span>, we can only perform point-transformations <span class="math inline">\(q = f(t, Q)\)</span>, lest the Euler–Lagrange equation is mangled, for the Hamiltonian, we can simultaneously transform both <span class="math inline">\(q, p\)</span>, while preserving the Hamiltonian equations of motion. Such transformations are called <strong>canonical transformations</strong>. They are of the form:</p>
<p><span class="math display">\[\begin{cases}
Q = f_Q(t, p, q)\\
P = f_P(t, p, q)
\end{cases}\]</span></p>
<p>where the functions <span class="math inline">\(f_Q, f_P: \R \times \R^N \times \R^N \to \R^N\)</span> are required to satisfy some functional equations.</p>
<p>This is usually derived by brute force without comments. However, to truly understand the meaning, we need to understand phase space from a perspective even more modern than <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span>.</p>
</section>
</section>
<section id="the-geometry-of-phase-space" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-geometry-of-phase-space">The geometry of phase space</h2>
<p>Given a state space <span class="math inline">\(\mathcal S\)</span>, both its configuration space and its phase space are obtained by attaching vector spaces to every point of it. Despite this, the geometry of phase space turns out to be a far richer thing than the geometry of configuration space. This fundamentally comes down to the difference between a cotangent vector and a tangent vector.</p>
<p>Consider an infinitesimal parallelogram in the phase space, around the point <span class="math inline">\((q, p)\)</span>. The parallelogram has (signed) sides <span class="math inline">\((\delta q_1, ..., \delta q_N; \delta p_1, ..., \delta p_N)\)</span>. What should be its (signed) <em>volume</em>? The natural answer is of course</p>
<p><span class="math display">\[\prod_i \delta q_i \delta p_i\]</span></p>
<p>but is this a meaningful answer? That is, is this a mirage in <span class="math inline">\(\R^N \times \R^N\)</span> created by our choice of coordinates, or is this a faithful representation of something that truly takes place in the phase space <span class="math inline">\(\mathcal T^\ast\mathcal S\)</span> itself?</p>
<p>This answer is critically important, since if a concept takes place in the phase space itself, then it will be coordinate-free, and every coordinate system automatically translates that one coordinate-free concept. This is how we could have predicted that the coordinate-based Euler–Lagrange equations are preserved, by going up to the coordinate-free version of it, then coming back down again.</p>
<p>Having a coordinate-free thing is like having a lingua-franca between different coordinate-based representations.</p>
<section id="poisson-bracket" class="level3">
<h3 class="anchored" data-anchor-id="poisson-bracket">Poisson bracket</h3>
<p>The <strong>Poisson bracket</strong> notation is convenient:</p>
<p><span class="math display">\[\{f, g\} = \sum_{i=1}^{N} \left( \frac{\partial f}{\partial q_{i}} \frac{\partial g}{\partial p_{i}} - \frac{\partial f}{\partial p_i} \frac{\partial g}{\partial q_i}\right)\]</span></p>
<p>For any differentiable function <span class="math inline">\(f(t, q, p)\)</span>, and any path <span class="math inline">\(p(t), q(t)\)</span> that conforms to a Hamiltonian <span class="math inline">\(H(t, q, p)\)</span>, we have by Hamiltonian’s equations of motion</p>
<p><span class="math display">\[\frac{d}{dt} f(t, p(t), q(t)) = \partial_t f(t, p(t), q(t)) + \{f, H\}\]</span></p>
<p>or more succinctly, <span class="math inline">\(\dot f = \partial_t f + \{f, H\}\)</span>.</p>
</section>
<section id="liouvilles-theorem" class="level3">
<h3 class="anchored" data-anchor-id="liouvilles-theorem">Liouville’s theorem</h3>
<p>Proof taken from <span class="citation" data-cites="tolmanPrinciplesStatisticalMechanics1980">(<a href="#ref-tolmanPrinciplesStatisticalMechanics1980" role="doc-biblioref">Tolman 1980, sec. 19</a>)</span>.</p>
</section>
<section id="the-interpretation-of-phase-space-geometry" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="the-interpretation-of-phase-space-geometry">The interpretation of phase space geometry</h3>
<p>Liouville’s theorem is a delicate construction, having several moving parts. We have a phase space, a volume-measurement on the phase space, a Hamiltonian on the phase space, and a density field on the phase space which flows according to the Hamiltonian. Only when all four moving parts come together do we get Liouville’s theorem.</p>
<p>What is a phase space, in the final analysis? A phase space <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span> is a state space <span class="math inline">\(\mathcal S\)</span>, with each state <span class="math inline">\(x\)</span> attached with <span class="math inline">\(\mathcal T^\ast_x \mathcal S\)</span>, the vector space of all possible momenta at that state. Good... but not quite! This interpretation of phase space is still bound firmly to the economic interpretation, where each momentum <span class="math inline">\(p\)</span> at state <span class="math inline">\(x\)</span> is a vector of prices, with which we are allowed to measure the profit flow, as <span class="math inline">\(\langle p, \dot x \rangle\)</span>.</p>
<p>While this perspective is how Hamiltonian mechanics got its start, the modern abstract viewpoint of Hamiltonian mechanics has sailed far away from the safe harbor of <span class="math inline">\(\R^{2N}\)</span>, past <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span>, and voyaged deep into the strange seas of symplectic geometry. Since the early days of the 20th century, there is a tacit understanding among physicists where the humble origin of the phase space <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span> is suppressed, and it is presented instead as a <span class="math inline">\(2N\)</span>-dimensional smooth manifold <span class="math inline">\(\mathcal P\)</span> equipped with some <span class="math inline">\(\omega\)</span>, a way to measure volumes. The seams where <span class="math inline">\(\mathcal T^\ast_x \mathcal S\)</span> was attached to <span class="math inline">\(\mathcal S\)</span> are now plastered over, never there, never will be mentioned again... And this abstract viewpoint actually works.</p>
<p>Speak not how the phase space was born, but what you can use it for! This is a principle useful not only in programming (encapsulation, API, abstract interfacing), but also in modern mathematics (speak not of equality, but equivalences and isomorphisms...), and perhaps in society (<em>Ye shall know them by their fruits. Do men gather grapes of thorns, or figs of thistles?</em>).</p>
<p>What do we gain and what do we lose when we go from <span class="math inline">\(\R^{2N}\)</span> to <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span> to <span class="math inline">\((\mathcal P, \omega)\)</span>? What we gain are new interpretations, and what we lose are old interpretations. See Table <a href="#table:three_abstractions" data-reference-type="ref" data-reference="table:three_abstractions">3</a>.</p>
<dl>
<dt>::: {#table:three_abstractions} <span class="math inline">\(\R^{2N}\)</span> <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span> <span class="math inline">\((\mathcal P, \omega)\)</span> ———————– ——————————– —————————- tuples of real number points, vectors, and covectors points, areas, and volumes multivariate calculus vector bundle geometry symplectic geometry</dt>
<dd>
<p>The three steps of abstraction. :::</p>
</dd>
</dl>
<p>In <span class="math inline">\(\R^{2N}\)</span>, we can interpret each point <span class="math inline">\((q, p)\in \R^{2N}\)</span> economically: <span class="math inline">\(q_1, ..., q_N\)</span> are the amounts of commodities, and <span class="math inline">\(p_1, ..., p_N\)</span> are their market prices. In <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span>, half of this interpretation is lost, since we are not allowed to interpret <span class="math inline">\(x\in \mathcal S\)</span> as a tuple of commodities, unless we lay down a more or less arbitrary coordinate system over it.</p>
<p>Nevertheless, half of this interpretation is preserved. While we are no longer able to interpret a point <span class="math inline">\(x\in \mathcal S\)</span> as a stock of commodities that we own, we are still able to interpret a vector <span class="math inline">\(v \in \mathcal T_x \mathcal S\)</span> as a <em>flow</em> of commodities. This then allows us to interpret <span class="math inline">\(\langle p, v \rangle\)</span> as a flow of profits: if we are producing at speed <span class="math inline">\(v\)</span>, and the market price vector is <span class="math inline">\(p\)</span>, then our profit flow is <span class="math inline">\(\langle p, v \rangle\)</span>. In economic language, we can’t talk of the stock, but we can still talk of the flow.</p>
<p>Giving up half of the economic interpretation allows us to gain in coordinate-freedom. The Hamiltonian equations of motion become coordinate-free equations on <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span>, and we are given the guarantee that it is preserved by any coordinate system on <span class="math inline">\(\mathcal S\)</span>.</p>
<p>When we get to <span class="math inline">\((\mathcal P, \omega)\)</span>, the economic interpretation is totally destroyed, because there is no more separation between commodities and prices. A point in <span class="math inline">\(\mathcal P\)</span> simply is a point <span class="math inline">\(y\in \mathcal P\)</span>, not a 2-tuple <span class="math inline">\((x, p)\)</span> with <span class="math inline">\(x\in \mathcal S\)</span> and <span class="math inline">\(p \in \mathcal T^\ast_x\mathcal S\)</span>. There is no way to seize the "second half" of <span class="math inline">\(y\)</span> and interpret it as a price vector.</p>
<p>Furthermore, we cannot even interpret it as a physical state with a momentum covector, either. A momentum covector still looks like an arrow. It has a direction, a length, and can be scaled linearly, and added. Out there in <span class="math inline">\(\mathcal P\)</span>, every point is just a point, not "half base point, half vector" like for <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span>.</p>
<p>Giving this much up allows us to gain in even more coordinate-freedom. We are allowed to interpret a physical system not as a <em>base state</em> <span class="math inline">\(x\in \mathcal S\)</span> plus a <em>momentum state</em> <span class="math inline">\(p \in \mathcal T^\ast_x\mathcal S\)</span> , but simply as a <em>phase state</em> <span class="math inline">\(y\in \mathcal P\)</span>. This in particular gives us the freedom to consider coordinate systems on <span class="math inline">\(\mathcal P\)</span> that are "fully nonlinear", which is what canonical transforms are all about.</p>
<p>Recall how we defined point transforms in Lagrangian mechanics. We start with a coordinate system <span class="math inline">\((q_1, ..., q_N)\)</span> on an open subset <span class="math inline">\(U\)</span> of the state space <span class="math inline">\(\mathcal S\)</span>, then <em>induced</em> a coordinate system <span class="math inline">\((q_1, ..., q_N; v_1, ..., v_N)\)</span> on <span class="math inline">\(\mathcal T U\)</span>. We also stated that, while we could have went directly for a coordinate system on <span class="math inline">\(\mathcal T\)</span>, this would break the Euler–Lagrange equation.</p>
<p>It turns out that the Hamiltonian equations of motion are sturdier than the Euler–Lagrange equation: there are large families of coordinate systems <span class="math inline">\((q_1, ..., q_N; p_1, ..., p_N)\)</span> that we can <em>directly</em> define on open subsets of <span class="math inline">\(\mathcal T^\ast \mathcal S\)</span>, and the resulting coordinate-based Hamiltonian equations would <em>still</em> be <span class="math inline">\(\dot p = -\nabla_q H, \dot q = \nabla_p H\)</span>, even if <span class="math inline">\((q_1, ..., q_N; p_1, ..., p_N)\)</span> is <em>not</em> induced by <em>any</em> coordinate system on the state space!</p>
<p>To fully exploit the freedom, of course, means that we must break down the strict segregation between a state-point and a momentum-vector. In particular, this means that we no longer require <span class="math inline">\(\mathcal T_x \mathcal S\)</span> to be treated with the rigid dignity of a linear space, but the rough freedom of a manifold space:</p>
<p><span class="math display">\[p(x, ku) \neq k p(x, u) \text { in general, for } (x, u)\in \mathcal T^\ast \mathcal S, \: k\in \R\]</span></p>
<p>Given that, we can immediately see why canonical transforms are in general of the form</p>
<p><span class="math display">\[Q(t, x, u) = f_Q(t, q(t, x, u), p(t, x, u)),\quad P(t, x, u) = f_P(t, q(t, x, u), p(t, x, u))\]</span></p>
<p>or more succinctly,</p>
<p><span class="math display">\[Q = f_Q(t, q, p),\quad P = f_P(t, q, p)\]</span></p>
<p>They have to nonlinearly "mix up" state and momentum, because that’s the only way to truly exploit all the freedoms that the sturdy Hamiltonian’s equations of motion grants us.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Mathematicians exploit every freedom that they are given... sounds evil, but it works in math.</p></div></div><p>Of course, the Hamiltonian equations are not <em>that tough</em>. Some restraint is needed. Not everything goes. What is the restraint? The volume must be preserved! That is precisely what <span class="math inline">\(\omega\)</span> is there for: it measures areas. A coordinate system on the phase space is only given the title of "canonical" iff the coordinate system represents <span class="math inline">\(\omega\)</span> correctly.</p>
<p>Thus, we find that by exploiting exactly as much freedom as Hamiltonian mechanics gives us, while keeping track of the boundaries so that we are not giving ourselves too much freedom and shooting ourselves in the foot, we walked inexorably into treating the phase space as <span class="math inline">\((\mathcal P, \omega)\)</span> – as an object of symplectic geometry.</p>
</section>
</section>
<section id="all-the-variational-principles-of-physics-that-youre-likely-to-ever-see" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="all-the-variational-principles-of-physics-that-youre-likely-to-ever-see">All the variational principles of physics that you’re likely to ever see</h2>
<p>Based on <span class="citation" data-cites="lanczosVariationalPrinciplesMechanics1970">(<a href="#ref-lanczosVariationalPrinciplesMechanics1970" role="doc-biblioref">Lanczos 1970</a>)</span>.</p>
<p>Others not covered: D’lambert’s principle. Gauss’s principle of least constraint, Hertz principle of least curvature, etc.</p>
<p>Let’s be clear here.</p>
<ul>
<li>a <strong>variation</strong> of a function <span class="math inline">\(\gamma: \R^n \to \R^m\)</span> is a function <span class="math inline">\(\gamma + \delta \eta\)</span>, such that <span class="math inline">\(\eta: \R^n \to \R^m\)</span>, and <span class="math inline">\(\delta\)</span> is an infinitesimal.</li>
<li>a <strong>constrained variation</strong> of a function <span class="math inline">\(\gamma\)</span> is a variation <span class="math inline">\(\gamma + \delta \eta\)</span>, such that <span class="math inline">\(\eta\)</span> satisfies certain constraints <span class="math inline">\(c\)</span>.</li>
<li>a <strong>functional</strong> is a function that maps a function to a real number. For example, the Lagrangian action <span class="math inline">\(S\)</span> is a functional, defined by</li>
</ul>
<p><span class="math display">\[S(\gamma) = \int L(t, \gamma(t), \dot \gamma(t))dt.\]</span></p>
<ul>
<li>a functional <span class="math inline">\(S\)</span> has <strong>zero variation</strong> at <span class="math inline">\(\gamma\)</span> under constraint <span class="math inline">\(c\)</span> iff for any variation <span class="math inline">\(\delta\eta\)</span> satisfying constraint <span class="math inline">\(c\)</span>, we have <span class="math inline">\(S(\gamma + \delta \eta) = S(\gamma) + o(\delta)\)</span>. We often write it simply as <span class="math inline">\((\delta S(\gamma))_c = 0\)</span>.</li>
<li><strong>variational calculus</strong> is a collection of techniques for solving calculus problems involving variations.</li>
<li>a <strong>variational principle</strong> is a statement with the following format:</li>
</ul>
<p>::: center A trajectory <span class="math inline">\(\gamma\)</span> of the system is a physically valid trajectory iff <span class="math inline">\((\delta S(\gamma))_c = 0\)</span>. :::</p>
<p>Now that we are clear on that, we can tabulate just about every variational principles of physics that you’re likely to ever see in Table <a href="#table:var-prin" data-reference-type="ref" data-reference="table:var-prin">[table:var-prin]</a>.</p>
<div class="sidewaystable page-columns page-full">
<div class="tabulary page-columns page-full">
<p>1.0|L|L|L|L|L| name &amp; Where is the trajectory? &amp; specification &amp; constraint &amp; the functional<br>
Hamilton’s principle &amp; state spacetime &amp; Lagrangian <span class="math inline">\(L(t, q, v)\)</span> &amp; fixed <span class="math inline">\((t_0, q_0), (t_1, q_1)\)</span> &amp; <span class="math inline">\(\int_\gamma L(t, q, \dot q)dt\)</span><br>
modified Hamilton’s principle &amp; phase spacetime &amp; Hamiltonian <span class="math inline">\(H(t, q, p)\)</span> &amp; fixed <span class="math inline">\((t_0, q_0), (t_1, q_1)\)</span> &amp; <span class="math inline">\(\int_\gamma (\sum_i p_i \dot q_i - H(t, q, p))dt\)</span><br>
Maupertuis’ principle<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> &amp; phase space &amp; time-independent Hamiltonian <span class="math inline">\(H(q, p)\)</span> &amp; fixed <span class="math inline">\(q_0, q_1\)</span>, constant <span class="math inline">\(H(q, p)\)</span> &amp; <span class="math inline">\(\int_\gamma \sum_i p_i dq_i\)</span><br>
Jacobi’s form of Maupertuis’ principle &amp; state space &amp; Lagrangian of form <span class="math inline">\(L(t, q, v) = \frac 12 v^T M v - V(q)\)</span> &amp; fixed <span class="math inline">\(q_0, q_1\)</span>, bonuded <span class="math inline">\(V(q) \leq 0\)</span> &amp; <span class="math inline">\(\int_\gamma \sqrt{(E - V(q)) dq^T M dq}\)</span><br>
timed Maupertuis’ principle &amp; state spacetime &amp; Lagrangian of form <span class="math inline">\(L(t, q, v) = \frac 12 v^T M v - V(q)\)</span> &amp; fixed <span class="math inline">\(q_0, q_1\)</span>, constant <span class="math inline">\(\frac 12 \dot q^T M \dot q + V(q)\)</span> &amp; <span class="math inline">\(\int_\gamma (\dot q^T M \dot q) dt\)</span><br>
Fermat’s principle of stationary pathlength<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> &amp; state space &amp; Lagrangian of form <span class="math inline">\(L(t, q, v) = \frac 12 v^T M v\)</span> &amp; fixed <span class="math inline">\(q_0, q_1\)</span>, constant <span class="math inline">\(\frac 12 \dot q^T M \dot q\)</span> &amp; <span class="math inline">\(\int_\gamma \sqrt{dq^T M dq}\)</span><br>
Fermat’s principle of stationary time &amp; state spacetime &amp; Lagrangian of form <span class="math inline">\(L(t, q, v) = \frac 12 v^T M v\)</span> &amp; fixed <span class="math inline">\(q_0, q_1\)</span>, constant <span class="math inline">\(\frac 12 \dot q^T M \dot q\)</span> &amp; <span class="math inline">\(t_1 - t_0\)</span><br>
</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;"principle of least action" in <span class="citation" data-cites="goldsteinClassicalMechanics2008">(<a href="#ref-goldsteinClassicalMechanics2008" role="doc-biblioref">Goldstein, Poole, and Safko 2008</a>)</span></p></div><div id="fn3"><p><sup>3</sup>&nbsp;Corollary: Hertz’s principle of least curvature</p></div></div></div>
</div>
<section id="hamiltons-principle-and-modified-hamiltons-principle" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="hamiltons-principle-and-modified-hamiltons-principle">Hamilton’s principle and modified Hamilton’s principle</h3>
<p>There are two principles that are often confused with impunity by physicists. The fact is that they are indeed equivalent (which is why they can be confused with impunity), but that is no excuse for bad mathematics.</p>
<p>Hamilton’s principle is a principle about trajectories of type <span class="math inline">\(\gamma: [t_0, t_1] \to \mathcal S\)</span>. That is, <span class="math inline">\(\gamma(t)\)</span> is a state of the system. Variations can be thought of as making a state perturbation <span class="math inline">\(\delta \eta(t)\)</span> at every time.</p>
<p>In contrast, modified Hamilton’s principle is a principle about trajectories of type <span class="math inline">\(\Gamma: [t_0, t_1] \to \mathcal P\)</span>. That is, <span class="math inline">\(\Gamma(t)\)</span> is a <em>phase</em> of the system, specifying both its state and momentum. Variations can be thought of as making a state perturbation <span class="math inline">\(\delta \eta_p(t)\)</span> and a momentum perturbation <span class="math inline">\(\delta \eta_p(t)\)</span> at every time.</p>
<p>One may object that modified Hamilton’s principle is performing physically impossible variations: how could you perform variations on position and momentum <em>independently of each other</em>? Shouldn’t we have <span class="math inline">\(\delta p = m\delta \dot q = \delta (\nabla_{v} L(t, q, \dot q))\)</span> at all times? To this objection, there are four layers of replies.</p>
<ol type="1">
<li><p>The equivalence of Hamilton’s principle and modified Hamilton’s principle, to be proved below, is a theorem in pure mathematics. It makes no demand on physical reality. It merely states that Hamilton’s principle specifies the same trajectories as modified Hamilton’s principle. Consequently, <em>if</em> it happens that these trajectories are physically real, then they can be specified by either principle.</p></li>
<li><p>The economic interpretation of momentum <span class="math inline">\(p\)</span> is merely the market price. The equation <span class="math inline">\(p = \nabla_{v} L(t, q, \dot q)\)</span> is true <em>if</em> we also assume that the producer is profit-maximizing. Now, if the trajectory <span class="math inline">\(\gamma\)</span> is optimal, then it implies that the producer is profit-maximizing. But after a perturbation of <span class="math inline">\(\gamma\)</span> to <span class="math inline">\(\gamma + \delta \eta\)</span>, the producer is not necessarily profit-maximizing.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>&nbsp;Consequently, even in Hamilton’s principle, there is no requirement that <span class="math inline">\(p = \nabla_{v} L(t, q, \dot q)\)</span>. The modified Hamilton’s principle makes this interactive dance between the producer and the market explicit: we allow both the production schedule and the market price schedule to vary independently. Then, the equation <span class="math inline">\(\delta \int (\sum_i p_i \dot q_i - H)dt = 0\)</span> is a statement about the trajectory of the producer-market system, and solving it would simultaneously solve both the producer and the market. In contrast, the equation <span class="math inline">\(\delta \int L dt = 0\)</span> is a statement about the producer, and solving it by imagining a market <span class="math inline">\(p\)</span> is useful, but not necessary.</p></li>
<li><p>Even in classical mechanics, momentum is not <em>real</em>. We are fooled by our long habit of thinking about classical mechanics as if it is merely a more mathematical version of our intuition. Classical mechanics is actually unintuitive.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> In classical mechanics, there is no necessary connection between momentum and velocity – "If <span class="math inline">\(L = \frac 12 v^T M v\)</span>, then <span class="math inline">\(p = Mv\)</span> on physically valid paths" actually needs to be <em>proved</em> from Hamilton’s principle, not baked into the definition of momentum!</p></li>
<li><p>Though in classical mechanics, both principles are equivalent, in modern physics, the modified Hamilton’s principle is primary, and the Hamilton’s principle a mere derivative. Furthermore, the phase space is primary, and the division of it into position-momentum is arbitrary. At a more fundamental level, there is no distinction between position and momentum. A "rotation in phase space" can transform position and momentum into each other.</p></li>
</ol>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;Unless the market price is perturbed in just the right way to make the producer profit-maximizing – If the producer messes up, the market can still accommodate the producer and make the producer look as if it is still profit-maximizing... Just like Potemkin villages!</p></div><div id="fn5"><p><sup>5</sup>&nbsp;Why else did Newton come two thousand years after Aristotle? Though quantum mechanics is certainly more unintuitive.</p></div></div><div id="thm-hp-mhp-equivalent" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Hamilton’s principle and modified Hamilton’s principle are equivalent.)</strong></span> Given a state space <span class="math inline">\(\mathcal S\)</span>, a Lagrangian <span class="math inline">\(L(t, q, v)\)</span> on the configuration space, and a Hamiltonian <span class="math inline">\(H(t, q, p)\)</span> on the phase space, related by convex duality, then a path <span class="math inline">\(\gamma: [t_0, t_1] \to \mathcal S\)</span> on state space satisfies</p>
<p><span class="math display">\[\delta \int_\gamma L(t, q, \dot q) dt = 0\]</span></p>
<p>with fixed <span class="math inline">\((t_0, q_0), (t_1, q_1)\)</span>, iff its corresponding path <span class="math inline">\(\Gamma: [t_0, t_1]: \to \mathcal T^\ast \mathcal S\)</span> on phase space satisfies</p>
<p><span class="math display">\[\delta \int_\Gamma \sum_i p_i \dot q_i - H(t, q, p) dt = 0\]</span></p>
<p>with fixed <span class="math inline">\((t_0, q_0), (t_1, q_1)\)</span> (and variable <span class="math inline">\(p_0, p_1\)</span>).</p>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Proof">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Proof
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p><span class="math inline">\((\Rightarrow):\)</span> Since <span class="math inline">\(\gamma\)</span> has zero variation for the action <span class="math inline">\(\int_\gamma L(t, q, \dot q)dt\)</span>, and <span class="math inline">\(H\)</span> is related to <span class="math inline">\(L\)</span> by convex duality, by our previous results, the Hamiltonian equations of motion are satisfied along <span class="math inline">\(\gamma\)</span>. That is, <span class="math inline">\(-\nabla_q H = \dot p, \nabla_p H = \dot p\)</span>.</p>
<p>Perform variation <span class="math inline">\(\Gamma + \delta \eta\)</span> on phase space. The variation in the action is</p>
<p><span class="math display">\[\begin{aligned} \delta S(\Gamma) &amp;= \int_{t_0}^{t_1} [\langle \delta p, \dot q\rangle + \langle  p, \delta \dot q\rangle - \langle \nabla_q H, \delta q\rangle - \langle \nabla_p H, \delta p\rangle ] dt \\ &amp;= \int_{t_0}^{t_1} [\langle \delta p, \dot q\rangle + \langle  p, \delta \dot q\rangle - \langle -\dot p, \delta q\rangle - \langle \dot q, \delta p\rangle ] dt \\ &amp;= \int_{t_0}^{t_1} [\langle  p, \delta \dot q\rangle + \langle \dot p, \delta q\rangle] dt \\ &amp;= \langle p, \delta q\rangle \Big|_{t_0}^{t_1} = 0 \end{aligned}\]</span></p>
<p>since <span class="math inline">\(\delta q= 0\)</span> at the end points.</p>
<p><span class="math inline">\((\Leftarrow):\)</span> Since <span class="math inline">\(\delta \int_\Gamma \sum_i p_i \dot q_i - H(t, q, p) dt = 0\)</span> at <span class="math inline">\(\Gamma\)</span> under constraint of fixed <span class="math inline">\((t_0, q_0), (t_1, q_1)\)</span>, it must also have zero variation if we use the stronger constraint of fixed <span class="math inline">\((t_0, q_0, p_0), (t_1, q_1, p_1)\)</span>. Then the Euler–Lagrange equations state<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p><span class="math display">\[-\nabla_q H = \dot p, \quad \nabla_p H = \dot p\]</span></p>
<p>which, as we proved, are precisely the conditions (no arbitrage pricing, and stationary profit flow) for <span class="math inline">\(\delta \int_\gamma L = 0\)</span>.</p>
</div>
</div>
</div>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;One can interpret this as treating the phase space <em>as if</em> it is a state space of a physical system with <span class="math inline">\(2N\)</span> degrees of freedom.</p></div></div></section>
<section id="maupertuis-principle" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="maupertuis-principle">Maupertuis’ principle</h3>
<p>Maupertuis’ principle is a principle for specifying <strong>orbits</strong> in phase space. An orbit is a trajectory of the physical system, but with timing information lost. We know that the system traveled through the states on the orbit, one after another, but we don’t know how fast is the traversal.</p>
<p>In order to be very explicit about it, we will write orbits in phase space as <span class="math inline">\(\mu: [a, b] \to \mathcal P\)</span>. Here <span class="math inline">\(a, b\)</span> look like "start and end times" and <span class="math inline">\(\mu(s)\)</span> looks like "location of the path at time <span class="math inline">\(s\)</span>", but <span class="math inline">\(s\)</span> is not time, and <span class="math inline">\(a, b\)</span> are not moments in time either. It is really just a parametrization of the curve, with no implications about how fast, or how slow, the system would actually traverse the orbit.</p>
<p>The integral <span class="math inline">\(\int_\mu \sum_i p_i \dot q_i ds\)</span> is unchanged by stretching and pressing the timing of <span class="math inline">\(\mu\)</span>. That is, let <span class="math inline">\(f: [a', b'] \to [a, b]\)</span> be a strictly increasing differentiable function, then <span class="math inline">\(\int_{\mu\circ f} \sum_i p_i \dot q_i ds = \int_\mu \sum_i p_i \dot q_i ds\)</span>. Consequently, Maupertuis’ principle is really concerned only with the orbit, not the timing of the orbit.</p>
<p>Since timing is lost, the constraint of fixed <span class="math inline">\((t_0, q_0), (t_1, q_1)\)</span> cannot apply. However, merely fixing <span class="math inline">\(q_0, q_1\)</span> is too little constraint. The solution is to add a new constraint: the variation must stay on the surface of constant energy <span class="math inline">\(E\)</span>. That is, <span class="math inline">\(H(\mu'(s')) = E\)</span> for any variation <span class="math inline">\(\mu'\)</span> and parameter <span class="math inline">\(s'\)</span>. This is how we arrive at Maupertuis’ principle.</p>
<p>::: prop</p>
<p>When the Hamiltonian is time-independent, Hamilton’s principle and Maupertuis’ principle are equivalent (after a retiming scaling).</p>
<p>Given phase space <span class="math inline">\(\mathcal P\)</span> and a time-independent Hamiltonian <span class="math inline">\(H(q, p)\)</span> over the phase space, such that <span class="math inline">\((\nabla_q H, \nabla_p H)\)</span> is never zero, then any trajectory <span class="math inline">\(\gamma: [t_0, t_1] \to \mathcal P\)</span> that satisfies Hamilton’s principle also satisfies Maupertuis’ principle.</p>
<p>Conversely, given any orbit <span class="math inline">\(\mu: [a, b] \to \mathcal P\)</span> with constant <span class="math inline">\(H\)</span> that satisfies Maupertuis’ principle, there exists a "retiming map" <span class="math inline">\(f: [t_0, t_1]\to [a, b]\)</span> such that <span class="math inline">\(f\)</span> is monotonically increasing, and <span class="math inline">\(\mu\circ f\)</span> satisfies Hamilton’s principle. :::</p>
<p>::: proof <em>Proof.</em> We show that Maupertuis’ principle is equivalent to Hamilton’s equations of motion after a retiming map.</p>
<p>Consider orbit <span class="math inline">\(\mu: [a, b] \to \mathcal P\)</span> in phase space, with constant <span class="math inline">\(H(\mu(s)) = E_0\)</span>. By integration-by-parts, we have</p>
<p><span class="math display">\[\delta \int \langle p, \dot q\rangle ds = \int \langle \delta p, \dot q\rangle - \langle \dot p, \delta  q\rangle ds + \cancel{\langle p, \delta q\rangle} \Big|_{a}^{b}\]</span></p>
<p>where the variation fixes <span class="math inline">\(q_0, q_1\)</span> and <span class="math inline">\(H\)</span>.</p>
<p>Now, <span class="math inline">\(\delta H = \langle \nabla_p H, \delta p\rangle +  \langle \nabla_q H, \delta q\rangle = 0\)</span>. So, if the orbit satisfies Hamilton’s equations of motion after a retiming map <span class="math inline">\(f\)</span>, that is,</p>
<p><span class="math display">\[\begin{cases}     \dot p = -f'(s)\nabla_p H \\     \dot q = f'(s)\nabla_q H \end{cases}\]</span></p>
<p>then plugging it back, we get</p>
<p><span class="math display">\[\delta \int \langle p, \dot q\rangle ds = \int f'(s) \delta H ds = 0\]</span></p>
<p>It is routine to check that, given four vectors <span class="math inline">\(a, b, c, d\in \R^N\)</span>, if <span class="math inline">\(\forall x, y\in \R^N\)</span>,</p>
<p><span class="math display">\[\langle a, x\rangle - \langle b, y\rangle = 0 \implies \langle c, x\rangle - \langle d, y\rangle = 0\]</span></p>
<p>then there exists <span class="math inline">\(\lambda &gt; 0\)</span> such that <span class="math inline">\(c = \lambda a, d = \lambda d\)</span>.</p>
<p>Thus, if the variation is zero for all <span class="math inline">\(\delta q, \delta p\)</span> with fixed <span class="math inline">\(H\)</span>, then there exists some continuous and positive function <span class="math inline">\(\lambda: [a, b] \to \R\)</span> such that</p>
<p><span class="math display">\[\begin{cases}     \dot p = -\lambda(s)\nabla_p H \\     \dot q = \lambda(s)\nabla_q H \end{cases}\]</span></p>
<p>Now solve for <span class="math inline">\(f' = \lambda^{-1}\)</span> by integration<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>, then <span class="math inline">\(f\)</span> is the desired retiming map.&nbsp;◻ :::</p>
<div class="no-row-height column-margin column-container"><div id="fn7"><p><sup>7</sup>&nbsp;Since <span class="math inline">\(\lambda\)</span> is continuous and positive, with compact domain, its range must be bounded below by some positive constant <span class="math inline">\(\epsilon &gt; 0\)</span>, thus the integration would not diverge.</p></div></div></section>
</section>
<section id="canonical-transformations" class="level2">
<h2 class="anchored" data-anchor-id="canonical-transformations">Canonical transformations</h2>
<section id="generating-functions" class="level3">
<h3 class="anchored" data-anchor-id="generating-functions">Generating functions</h3>
<p>The dynamics of a physical system can be fully defined by its Lagrangian function. However, the Lagrangian function is not fully defined by the dynamics. There are many possible functions that can all play the role of the Lagrangian.</p>
<p>Suppose <span class="math inline">\(L(t, q, v)\)</span> is a Lagrangian function, then take any twice-differentiable function <span class="math inline">\(F(t, q)\)</span>, and define</p>
<p><span class="math display">\[L' dt := L dt + dF\]</span></p>
<p>which implies</p>
<p><span class="math display">\[L'(t, q, v) := L(t, q, v) + \partial_t F(t, q) + \langle \nabla_q F(t, q), v\rangle\]</span></p>
<p>then it is easy to directly verify that a trajectory <span class="math inline">\(\gamma(t)\)</span> satisfies the Euler–Lagrange equations for <span class="math inline">\(L\)</span> iff it satisfies them for <span class="math inline">\(L'\)</span>. Consequently, both <span class="math inline">\(L\)</span> and <span class="math inline">\(L'\)</span> are different functions that can both play the role of Lagrangian for the same physical system.</p>
<p>Instead of directly computing the Euler–Lagrangian equations, we can also do it directly by variational principles: For any trajectory <span class="math inline">\(\gamma: [t_0, t_1] \to \mathcal S\)</span> we have</p>
<p><span class="math display">\[\int_{t_0}^{t_1} L'(t, \gamma(t), \dot \gamma(t))dt = F(t, \gamma(t))|_{t_0}^{t_1} + \int_{t_0}^{t_1} L(t, \gamma(t), \dot \gamma(t))dt\]</span></p>
<p>Consequently, <span class="math inline">\(\delta \int Ldt = 0\)</span> iff <span class="math inline">\(\delta \int L'dt = 0\)</span>, so a trajectory has stationary action according to one Lagrangian iff according to the other.</p>
<p>Such <span class="math inline">\(F(t, q)\)</span> are called a <strong>generating function</strong> for transforming a Lagrangian function. Generating functions are really just functions that are picked to play a certain role. That is, being a generating function is not an <em>intrinsic</em> property of a function, but <em>extrinsic</em>, because some human physicist has decided to use it for <em>generating</em> a new Lagrangian from an old one. This is why I don’t like saying "<span class="math inline">\(F\)</span> a generating function...". Instead, I prefer to say "Now we use <span class="math inline">\(F\)</span> to generate a new Lagrangian..." Nevertheless I am forced to use the term because it is a venerable error, a bug that became a feature.</p>
</section>
<section id="generating-functions-for-hamiltonians" class="level3">
<h3 class="anchored" data-anchor-id="generating-functions-for-hamiltonians">Generating functions for Hamiltonians</h3>
<p>Hamiltonians are freer than Lagrangians. Instead of one way, there are many ways to generate new Hamiltonians from old.</p>
<p>Taking inspiration from Lagrangian generating functions, we write down the following equation:</p>
<p><span class="math display">\[\langle p , dq \rangle - hdt = \langle P, dQ \rangle - Hdt + dG\]</span></p>
<p>where <span class="math inline">\(G: \R \times \mathcal P \to \R\)</span> is any twice-differentiable function on phase spacetime.</p>
<p>::: theorem If <span class="math inline">\((q, p), (Q, P)\)</span> are two coordinate systems on the phase spacetime, and <span class="math inline">\(h, H, G\)</span> are twice-differentiable functions on phase spacetime, and</p>
<p><span class="math display">\[\langle p , dq \rangle - hdt = \langle P, dQ \rangle - Hdt + dG\]</span></p>
<p>Then along any trajectory in phase spacetime, <span class="math inline">\((q, p)\)</span> satisfies Hamiltonian equations of motion for <span class="math inline">\(h\)</span>, iff <span class="math inline">\((Q, P)\)</span> satisfies Hamiltonian equations of motion for <span class="math inline">\(H\)</span>. :::</p>
<p>::: proof <em>Proof.</em> Let <span class="math inline">\(\gamma: [t_0, t_1] \to \mathcal P\)</span> be any trajectory, not necessarily satisfying Hamilton’s equations of motion. Then for any variation of <span class="math inline">\(\gamma\)</span> with fixed <span class="math inline">\(t_0, t_1\)</span>, we have by integration-by-parts,</p>
<p><span class="math display">\[\begin{aligned}     &amp;\delta\int_\gamma \langle p , dq \rangle - hdt = \delta\int_\gamma \langle P, dQ \rangle - Hdt + dG\\     &amp;= \int (\langle \delta P, \dot Q - \nabla_P H\rangle - \langle \dot P + \nabla_Q H, \delta Q\rangle ) dt + (\langle P, \delta Q \rangle + \delta G)\Big|_{t_0}^{t_1} \\     &amp;= \int (\langle \delta p, \dot q - \nabla_p h\rangle - \langle \dot p + \nabla_q h, \delta q\rangle ) dt + \langle p, \delta q \rangle \Big|_{t_0}^{t_1}  \end{aligned}\]</span></p>
<p>The boundary terms are equal, since <span class="math inline">\(\langle p , \delta q \rangle - h \delta t = \langle P, \delta Q \rangle - H\delta t + \delta G\)</span>, and <span class="math inline">\(\delta t = 0\)</span> as we fixed <span class="math inline">\(t_0, t_1\)</span>.</p>
<p>Thus, for any variation of <span class="math inline">\(\gamma\)</span> with fixed <span class="math inline">\(t_0, t_1\)</span>,</p>
<p><span class="math display">\[\int (\langle \delta p, \dot q - \nabla_p h\rangle - \langle \dot p + \nabla_q h, \delta q\rangle ) dt = \int (\langle \delta P, \dot Q - \nabla_P H\rangle - \langle \dot P + \nabla_Q H, \delta Q\rangle ) dt\]</span></p>
<p>Thus, if <span class="math inline">\(\gamma\)</span> satisfies Hamiltonian equations of motion for <span class="math inline">\((q, p), h\)</span>, then it also does so for <span class="math inline">\((Q, P), H\)</span>.&nbsp;◻ :::</p>
</section>
<section id="coordinate-based-canonical-transforms" class="level3">
<h3 class="anchored" data-anchor-id="coordinate-based-canonical-transforms">Coordinate-based canonical transforms</h3>
<p>This section might make more sense after reading the next section.</p>
<p>The equation</p>
<p><span class="math display">\[\langle p , dq \rangle - hdt = \langle P, dQ \rangle - Hdt + dG\]</span></p>
<p>lives in phase spacetime. That is, <span class="math inline">\(dq, dt, dQ, dG\)</span> are all differentials in <span class="math inline">\(\R \times \mathcal P\)</span>. This is elegant, but not good for concrete computations, which requires coordinate-based equations.</p>
<p>Generally, <span class="math inline">\(G(t, y)\)</span> is a function on phase spacetime, so it could be represented in any coordinate system of phase spacetime. For example, we can represent it as <span class="math inline">\(G(t, y) = G_{q, p}(t, q(t, y), p(t, y))\)</span>, or <span class="math inline">\(G(t, y) = G_{Q, P}(t, Q(t, y), P(t, y))\)</span>, or even mixed coordinates like <span class="math inline">\(G(t, y) = G_{q, P}(t, q(t, y), P(t, y))\)</span>, etc.</p>
<p>Most representations result in intractable coordinate-based equations, but a few are actually usable. These are traditionally classified as "type 1" to "type 5".</p>
<p><strong>Type 1</strong>: <span class="math inline">\(G(t, y) = F_1(t, q(t, y), Q(t, y))\)</span>.</p>
<p>Plugging it in, we find</p>
<p><span class="math display">\[\langle p , dq \rangle - hdt = \langle P, dQ \rangle - Hdt + \partial_t F_1 dt + \langle \nabla_q F_1, dq \rangle + \langle \nabla_Q F_1, dQ \rangle\]</span></p>
<p>yielding the equations</p>
<p><span class="math display">\[\begin{cases}     H(t, Q, P) = h(t, q, p) + \partial_t F_1(t, q, Q) \\     p = \nabla_q F_1(t, q, Q) \\     P = - \nabla_Q F_1(t, q, Q) \end{cases}\]</span></p>
<p>In order to solve for the canonical transform, first invert <span class="math inline">\(p = \nabla_p F_1(t, q, Q)\)</span> to obtain <span class="math inline">\(Q = f_Q(t, q, p)\)</span>, then plug it into <span class="math inline">\(P = - \nabla_Q F_1(t, q, Q)\)</span> to obtain <span class="math inline">\(P = f_P(t, q, p)\)</span>. Inverting them gives us <span class="math inline">\(q = g_q(t, Q, P), p = g_p(t, Q, P)\)</span>.</p>
<p>Then, given any Hamiltonian <span class="math inline">\(h(t, q, p)\)</span>, the corresponding <span class="math inline">\(H(t, Q, P)\)</span> is found by <span class="math inline">\(H(t, Q, P) = h(t, q, p) + \partial_t F_1(t, q, Q)\)</span>, or very explicitly,</p>
<p><span class="math display">\[H(t, Q, P) = h(t, g_q(t, Q, P), g_p(t, Q, P)) + \partial_t F_1(t, g_q(t, Q, P), Q)\]</span></p>
<p><strong>Type 2</strong>: <span class="math inline">\(G(t, y) = F_2(t, q(t, y), P(t, y)) - \langle P(t, y), Q(t, y)\rangle\)</span>.</p>
<p>Why <span class="math inline">\(\langle P, Q\rangle\)</span>? Directly writing down <span class="math inline">\(G = F_2(t, q, P)\)</span> results in the following equation:</p>
<p><span class="math display">\[\langle p , dq \rangle - hdt = \langle P, dQ \rangle - Hdt + \partial_t F_2 dt + \langle \nabla_q F_2, dq \rangle + \langle \nabla_P F_2, dP \rangle\]</span></p>
<p>Here, there is an entanglement between terms <span class="math inline">\(dq, dQ, dP\)</span>. Since there are only <span class="math inline">\(2N\)</span> dimensions in the phase space, but there are <span class="math inline">\(3N\)</span> differentials in <span class="math inline">\(dq, dQ, dP\)</span>, it must be possible to represent <span class="math inline">\(N\)</span> of them as a linear combination of the other <span class="math inline">\(2N\)</span> differentials. In particular, we can represent <span class="math inline">\(dQ\)</span> as a linear combination of <span class="math inline">\(dq, dP\)</span>.</p>
<p>Instead, we can directly cancel out <span class="math inline">\(\langle P, Q\rangle\)</span> from the equation by writing <span class="math inline">\(G\)</span> as <span class="math inline">\(G + \langle P, Q\rangle - \langle P, Q\rangle\)</span>, then represent <span class="math inline">\(G + \langle P, Q\rangle\)</span> as <span class="math inline">\(F_2(t, q, P)\)</span>. This then gives</p>
<p><span class="math display">\[\begin{cases}     H(t, Q, P) = h(t, q, p) + \partial_t F_2(t, q, P) \\     Q = \nabla_P F_2(t, q, P) \\     p = \nabla_q F_2(t, q, P) \end{cases}\]</span></p>
<p><strong>Type 3</strong>: <span class="math inline">\(G = F_3(t, p, Q) + \langle p, q\rangle\)</span>.</p>
<p><strong>Type 4</strong>: <span class="math inline">\(G = F_4(t, p, P) + \langle p, q\rangle  - \langle P, Q\rangle\)</span>.</p>
<p><strong>Type 5</strong>: <span class="math inline">\(G = F(t, p_{I_1}, q_{I_2}, P_{I_3}, Q_{I_4}) + \langle p_{I_1}, q_{I_1} \rangle - \langle P_{I_3}, Q_{I_3} \rangle\)</span>.</p>
<p><span class="math display">\[\begin{cases}     H(t, Q, P) = h(t, q, p) + \partial_t F(t, p_{I_1}, q_{I_2}, P_{I_3}, Q_{I_4}) \\     q_{I_1} = -\nabla_{p_{I_1}} F(t, p_{I_1}, q_{I_2}, P_{I_3}, Q_{I_4}) \\     p_{I_2} = \nabla_{q_{I_2}} F(t, p_{I_1}, q_{I_2}, P_{I_3}, Q_{I_4}) \\     Q_{I_3} = \nabla_{P_{I_3}} F(t, p_{I_1}, q_{I_2}, P_{I_3}, Q_{I_4}) \\     P_{I_4} = -\nabla_{Q_{I_4}} F(t, p_{I_1}, q_{I_2}, P_{I_3}, Q_{I_4}) \end{cases}\]</span></p>
<p>Here, <span class="math inline">\(I_1, I_2, I_3, I_4\)</span> stand for subsets of the indexing set <span class="math inline">\(\{1, 2, ..., N\}\)</span>. We also require <span class="math inline">\(I_1 \cup I_2 = I_3 \cup I_4 = \{1, 2, ..., N\}\)</span></p>
<p>Note that types 1 to 4 are all special cases of type 5.</p>
</section>
<section id="examples-of-canonical-transforms" class="level3">
<h3 class="anchored" data-anchor-id="examples-of-canonical-transforms">Examples of canonical transforms</h3>
<section id="point-transforms" class="level4">
<h4 class="anchored" data-anchor-id="point-transforms">Point transforms</h4>
<p>If <span class="math inline">\(G= 0\)</span>, then we need to solve only the equation <span class="math inline">\(\langle p, dq \rangle = \langle P, dQ \rangle\)</span>, which can be done in general iff <span class="math inline">\(dQ\)</span> is a linear combination of <span class="math inline">\(dq\)</span>, thus <span class="math inline">\(Q = f_Q(t, q)\)</span> for some function <span class="math inline">\(f_Q\)</span>. This is just the point transform, with solution</p>
<p><span class="math display">\[P = ([\nabla_q f_Q]^T)^{-1}p\]</span></p>
</section>
<section id="interpolating-a-canonical-transform" class="level4">
<h4 class="anchored" data-anchor-id="interpolating-a-canonical-transform">Interpolating a canonical transform</h4>
<p>Given any canonical transform from <span class="math inline">\((q, p)\)</span> to <span class="math inline">\((Q, P)\)</span>, for any two times <span class="math inline">\(t_0 &lt; t_1\)</span>, we can interpolate between <span class="math inline">\((q, p), (Q, P)\)</span> over the period <span class="math inline">\([t_0, t_1]\)</span>. That is, we construct a canonical transform from <span class="math inline">\((q, p)\)</span> to <span class="math inline">\((\bar q, \bar p)\)</span> such that <span class="math inline">\((\bar q, \bar p) = (q, p)\)</span> at <span class="math inline">\(t=t_0\)</span>, and <span class="math inline">\((\bar q, \bar p) = (Q, P)\)</span> at <span class="math inline">\(t = t_1\)</span>.</p>
<p>The idea is to note that any canonical transform can be written in type 2, including the identity transform.</p>
<p>The identity transform from <span class="math inline">\((q, p)\)</span> to <span class="math inline">\((\bar q, \bar p)\)</span> can be represented in type 2 as</p>
<p><span class="math display">\[G_0 = \langle q, \bar p \rangle - \langle \bar p, \bar q \rangle\]</span></p>
<p>Generate the transform from <span class="math inline">\((q, p)\)</span> to <span class="math inline">\((Q, P)\)</span> by <span class="math inline">\(G\)</span>, and represent it in type 2 as</p>
<p><span class="math display">\[G_1 = F_2(t, q, P) - \langle P, Q \rangle\]</span></p>
<p>Now interpolate them by</p>
<p><span class="math display">\[G = \frac{t_1-t}{t_1 - t_0} \langle q, \bar p \rangle + \frac{t - t_0}{t_1 - t_0} F_2(t, q, \bar p)  - \langle \bar p, \bar q \rangle\]</span></p>
</section>
<section id="time-evolution-is-a-canonical-transform-generated-by-the-action" class="level4">
<h4 class="anchored" data-anchor-id="time-evolution-is-a-canonical-transform-generated-by-the-action">Time-evolution is a canonical transform generated by the action</h4>
<p>Recall that, for any coordinate system <span class="math inline">\((q, p)\)</span> and Hamiltonian <span class="math inline">\(h\)</span>, we defined the action function ("Hamilton’s principal function") <span class="math inline">\(S(t_1, q_1; t_0, q_0)\)</span> to be the action for the path <span class="math inline">\(\gamma\)</span> from <span class="math inline">\((t_0, q_0)\)</span> to <span class="math inline">\((t_1, q_1)\)</span>. We also proved, during derivation of the HJE,</p>
<p><span class="math display">\[dS = \langle p_1, dq_1 \rangle -h(t_1, q_1, p_1) dt_1 - \langle p_0, dq_0 \rangle + h(t_0, q_0, p_0) dt_0\]</span></p>
<p>Rearrange, and using suggestive notation, we get...</p>
<p><span class="math display">\[\langle p_0, dq_0 \rangle - h_0 dt_0 = \langle p_1, dq_1 \rangle -h_1 dt_1 + dS\]</span></p>
<p>So we find that time evolution is a canonical transformation generated by <span class="math inline">\(S\)</span>.</p>
<p>In more detail, fix some coordinate system <span class="math inline">\((q, p)\)</span>. Then for any Hamiltonian <span class="math inline">\(\mathcal H : \R \times \mathcal P \to \R\)</span>, define its time-evolution function <span class="math inline">\(\phi\)</span>, such that <span class="math inline">\(\phi(t_0, t_1; y)\)</span> is the point that we end up with at time <span class="math inline">\(t_1\)</span>, if we start at <span class="math inline">\(y\)</span> at time <span class="math inline">\(t_0\)</span>, and evolve according to <span class="math inline">\(\dot q = \nabla_p h, \dot p = -\nabla_q h\)</span>, where <span class="math inline">\(h(t, q(t, x), p(t, x)) = \mathcal H(t, x)\)</span> is the coordinate-based version of the coordinate-free <span class="math inline">\(\mathcal H\)</span>.</p>
<p>Now, fix some time-interval <span class="math inline">\(s\in \R\)</span>, then define the (coordinate-free) function <span class="math inline">\(\mathcal G\)</span>, the action of the trajectory starting at <span class="math inline">\((t, y)\)</span> and lasting for <span class="math inline">\(s\)</span>:</p>
<p><span class="math display">\[\mathcal G(t, y) := S(t+s, q(t+s, \phi(t, t+s; y)); t, q(t, y))\]</span></p>
<p>and the new coordinate system with a new Hamiltonian, obtained by "evolving for <span class="math inline">\(s\)</span> time": <span class="math display">\[\begin{aligned} Q(t, y) = q(t+s, \phi(t, t+s; y)) \\ P(t, y) = p(t+s, \phi(t, t+s; y)) \\ H(t, Q(t, y), P(t, y)) = \mathcal H(t + s, \phi(t, t+s; y)) \end{aligned}\]</span></p>
<p>which allows a coordinate-based representation of <span class="math inline">\(\mathcal G\)</span>:</p>
<p><span class="math display">\[G(t, q, Q) = S(t+s, Q; t, q)\]</span></p>
<p>With these definitions, we have</p>
<p><span class="math display">\[dG = -Hdt + \langle P, dQ \rangle + hdt -\langle p, dq \rangle\]</span></p>
<p>that is, <span class="math inline">\((Q, P), H\)</span> is canonically transformed from <span class="math inline">\((q, p), h\)</span> via the function <span class="math inline">\(G\)</span>.</p>
</section>
</section>
<section id="simple-harmonic-oscillator" class="level3">
<h3 class="anchored" data-anchor-id="simple-harmonic-oscillator">Simple harmonic oscillator</h3>
<p>Consider a SHO with <span class="math inline">\(N\)</span> degrees of freedom. Its Hamiltonian is</p>
<p><span class="math display">\[H = \frac 12 p^T M^{-1} p + \frac 12 q^T K q\]</span></p>
<p>where <span class="math inline">\(M\)</span> is the matrix representing the masses of the system, and <span class="math inline">\(K\)</span> is the matrix representing the elastic constants of the system.</p>
<section id="translation-is-a-canonical-transform-generated-by-momentum" class="level4">
<h4 class="anchored" data-anchor-id="translation-is-a-canonical-transform-generated-by-momentum">Translation is a canonical transform generated by momentum</h4>
</section>
<section id="rotation-is-a-canonical-transform-generated-by-angular-momentum" class="level4">
<h4 class="anchored" data-anchor-id="rotation-is-a-canonical-transform-generated-by-angular-momentum">Rotation is a canonical transform generated by angular momentum</h4>
</section>
</section>
<section id="canonical-transforms-in-general" class="level3">
<h3 class="anchored" data-anchor-id="canonical-transforms-in-general">Canonical transforms, in general</h3>
<p>There are two possible ways to define canonical transforms. The more concrete way is by using generating functions: two coordinate systems <span class="math inline">\((q, p), (Q, P)\)</span> on phase spacetime are generated canonical transforms of each other iff</p>
<p><span class="math display">\[\langle p, dq\rangle - \langle P, dQ\rangle = dG\]</span></p>
<p>for some <span class="math inline">\(G\)</span> functions on phase spacetime. Remember that <span class="math inline">\(dq, dQ\)</span> are differentials with constant time.</p>
<p>As for the more abstract form... long story short: every canonical transform has a generating function. This is usually called "Carathéodory Theorem". See <span class="citation" data-cites="goldsteinClassicalMechanics2008">(<a href="#ref-goldsteinClassicalMechanics2008" role="doc-biblioref">Goldstein, Poole, and Safko 2008, sec. 9.5</a>)</span>.</p>
<p>This has a more elegant form with exterior calculus. Take exterior differentiation (again, only in phase space, not in time), we get</p>
<p><span class="math display">\[\sum_i dp_i \wedge dq_i = \sum_i dP_i \wedge dQ_i\]</span></p>
<p>Now take wedge product <span class="math inline">\(N\)</span> times with itself, we get</p>
<p><span class="math display">\[\bigwedge_i dp_i \wedge dq_i = \bigwedge_i dP_i \wedge dQ_i\]</span></p>
<p>Interpretation: canonical transforms preserve phase space volumes. That is, if we have an open subset in phase space, defined coordinate-free, then we can compute its volume by writing down a canonical coordinate system <span class="math inline">\((q, p)\)</span> and integrating <span class="math inline">\(\prod_i dp_i dq_i\)</span>. The result is unchanged by a canonical transform to <span class="math inline">\((Q, P)\)</span>.</p>
<p>This gives us a new proof of Liouville’s theorem:</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Since time-evolution is a canonical transform, time-evolution preserves volumes.</p>
<p>Given a particle flow in phase space, with density <span class="math inline">\(\rho(t, p, q)\)</span>, flowing according to Hamiltonian <span class="math inline">\(H(t, q, p)\)</span>. Take an infinitesimal cube around <span class="math inline">\((q, p)\)</span> at time <span class="math inline">\(t\)</span>, with volume <span class="math inline">\(\delta V = \prod_i \delta p_i \delta q_i\)</span>, then it contains <span class="math inline">\(\delta N = \rho(t, q, p) \delta V\)</span> number of particles. Then, let it flow for time <span class="math inline">\(s\)</span>.</p>
<p>The infinitesimal cube is transported to some other parallelogram around some point <span class="math inline">\((q', p')\)</span>, but its volume is unchanged, thus the density at the new location is still the same: <span class="math inline">\(\rho(t+s, q', p') = \rho(t, q, p)\)</span>. Thus <span class="math inline">\(\dot \rho = 0\)</span>.&nbsp;</p>
</div>
</section>
<section id="poisson-brackets-are-preserved-by-canonical-transforms" class="level3">
<h3 class="anchored" data-anchor-id="poisson-brackets-are-preserved-by-canonical-transforms">Poisson brackets are preserved by canonical transforms</h3>
<p>The Poisson bracket <span class="math inline">\(\{f, g\}\)</span> was defined in a coordinate-based way:</p>
<p><span class="math display">\[\{f, g\} = \sum_{i=1}^{N} \left( \frac{\partial f}{\partial q_{i}} \frac{\partial g}{\partial p_{i}} - \frac{\partial f}{\partial p_i} \frac{\partial g}{\partial q_i}\right)\]</span></p>
<p>We show that it is preserved by canonical transforms. That is, if <span class="math inline">\((Q, P)\)</span> is a canonical transform of <span class="math inline">\((p, q)\)</span> then</p>
<p><span class="math display">\[\sum_{i=1}^{N} \left( \frac{\partial f}{\partial q_{i}} \frac{\partial g}{\partial p_{i}} - \frac{\partial f}{\partial p_i} \frac{\partial g}{\partial q_i}\right) = \sum_{i=1}^{N} \left( \frac{\partial f}{\partial Q_{i}} \frac{\partial g}{\partial P_{i}} - \frac{\partial f}{\partial P_i} \frac{\partial g}{\partial Q_i}\right)\]</span></p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>(From the Landau–Lifshitz textbook) Since the Poisson bracket does not depend on time, and if <span class="math inline">\(Q(t, q, p), P(t, q, p)\)</span> is a canonical transform, so is <span class="math inline">\(Q(t, q, p), P(t, q, p)\)</span>, so we consider only canonical transforms that are independent of time.</p>
<p>If we started with only <span class="math inline">\(f(q, p), g(q, p)\)</span>, then extend them to phase spacetime by</p>
<p><span class="math display">\[\mathcal F(t, y) = f(q(0, y), p(0, y)),\quad \mathcal G(t, y) = g(q(0, y), p(0, y))\]</span></p>
<p>Next, impose <span class="math inline">\(\mathcal G\)</span> as a Hamiltonian, and evolve the physical system according to Hamilton’s equations of motion for <span class="math inline">\((q, p), \mathcal G\)</span>. Since <span class="math inline">\((q, p)\)</span> and <span class="math inline">\((Q, P)\)</span> are canonical transforms of each other, we have</p>
<p><span class="math display">\[\{\mathcal F, \mathcal G\}_{q, p} + \partial_t \mathcal F = \dot{\mathcal F} = \{\mathcal F, \mathcal G'\}_{Q, P} + \partial_t \mathcal F\]</span></p>
<p>Okay, what is <span class="math inline">\(\mathcal G'\)</span>? It is a solution to</p>
<p><span class="math display">\[\langle p, dq \rangle - \mathcal G dt  = \langle P, dQ \rangle - \mathcal G' dt + d\mathcal K\]</span></p>
<p>since <span class="math inline">\(\mathcal K\)</span> does not depend on time, <span class="math inline">\(d\mathcal K\)</span> contains zero <span class="math inline">\(dt\)</span> term, so <span class="math inline">\(\mathcal G = \mathcal G'\)</span>.</p>
</div>
</section>
<section id="interpretation-of-canonical-transforms" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-of-canonical-transforms">Interpretation of canonical transforms</h3>
<p>What is invariant under canonical transforms is what is really real about the physical system. Other things are mirages, illusions caused by our choice of coordinates.</p>
<p>Thus, position and momentum are mirages. Hamiltonian equations are real. <span class="math inline">\(p, q\)</span> are mirages. <span class="math inline">\(\int \sum_i p_i dq_i\)</span> is real. <span class="math inline">\(\nabla_p, \nabla_q\)</span> are mirages. Poisson brackets <span class="math inline">\(\{f, g\}\)</span> are real. Phase space lengths <span class="math inline">\(dp, dq\)</span> are mirages. Phase space areas <span class="math inline">\(\sum_i p_i dq_i\)</span>, volumes <span class="math inline">\(\prod_i dp_i dq_i\)</span>, and densities <span class="math inline">\(\rho\)</span> are real.</p>



</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bohnStudentGuideAnalytical2018" class="csl-entry" role="listitem">
Bohn, John L. 2018. <em>A <span>Student</span>’s <span>Guide</span> to <span>Analytical Mechanics</span></em>. 1st edition. Cambridge ; New York, NY: Cambridge University Press.
</div>
<div id="ref-goldsteinClassicalMechanics2008" class="csl-entry" role="listitem">
Goldstein, Herbert, Charles P. Poole, and John L. Safko. 2008. <em>Classical Mechanics</em>. 3. ed., [Nachdr.]. San Francisco Munich: Addison Wesley.
</div>
<div id="ref-lanczosVariationalPrinciplesMechanics1970" class="csl-entry" role="listitem">
Lanczos, Cornelius. 1970. <em>The Variational Principles of Mechanics</em>. 4th ed. Mathematical Expositions, no. 4. Toronto: University of Toronto Press.
</div>
<div id="ref-tolmanPrinciplesStatisticalMechanics1980" class="csl-entry" role="listitem">
Tolman, Richard C. 1980. <em>The Principles of Statistical Mechanics</em>. Unabridged and unaltered republ. of the original (1938) ed. Dover Books on Physics. New York, NY: Dover.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/yuxi-liu-wired\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><span class="faux-block">Everything ©<a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a></span></p>
</div>   
    <div class="nav-footer-center">
<p><span class="faux-block">Yuxi on the Wired</span></p>
</div>
    <div class="nav-footer-right">
<p><span class="faux-block"><a href="../../../sitemap.xml">sitemap</a></span></p>
</div>
  </div>
</footer>




</body></html>