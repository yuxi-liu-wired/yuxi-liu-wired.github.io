<!DOCTYPE html>
<html>

<head>
    <title>D3 Visualization</title>
    <script src="static/d3.min.js"></script>
    <style>
    </style>
</head>

<body>

    <!-- SVG Container -->
    <div id="svg-container"></div>

    <script>
        function squareSVG(p_innocent_input, p_true_innocent_input, p_false_innocent_input) {
            // SVG setup
            let p_innocent = p_innocent_input;
            let p_true_innocent = p_true_innocent_input;
            let p_false_innocent = p_false_innocent_input;

            const width = 300; // Width of the SVG
            const height = 300; // Height of the SVG  

            const svg = d3.select('#svg-container').append('svg')
                .attr('width', width * 2)
                .attr('height', height + 40)
                .attr("viewBox", `-150 -40 600 380`)
                .style("border", "0px solid black");

            let textElement = svg.append("text")
                .attr("x", 150) // Center the text
                .attr("y", height + 20) // Position below the square
                .attr("text-anchor", "middle") // Center the text horizontally
                .text(``);

            svg.append("text").attr("x", -10).attr("y", 40).attr("text-anchor", "end").text(`judged innocent`);
            svg.append("text").attr("x", -10).attr("y", 280).attr("text-anchor", "end").text(`judged guilty`);
            svg.append("text").attr("x", 20).attr("y", -10).attr("text-anchor", "start").text(`actually innocent`);
            svg.append("text").attr("x", 300).attr("y", -10).attr("text-anchor", "end").text(`actually guilty`);

            const colorTopLeft = "#ABD2FA";
            const colorTopRight = "#3D518C";
            const colorBottomLeft = "#7692FF";
            const colorBottomRight = "#091540";

            // Append the colored rectangles before the lines so they are drawn underneath
            let regionTopLeft = svg.append("rect")
                .attr("fill", colorTopLeft);

            let regionTopRight = svg.append("rect")
                .attr("fill", colorTopRight);

            let regionBottomLeft = svg.append("rect")
                .attr("fill", colorBottomLeft);

            let regionBottomRight = svg.append("rect")
                .attr("fill", colorBottomRight);
            // Draw the square
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("fill", "none")
                .attr("stroke", "none");

            let linecolor = "#A31621"
            let trueInnocentLine = svg.append("line")
                .attr("stroke", linecolor)
                .attr("stroke-width", 10)
                .attr("x1", 0)
                .attr("x2", p_innocent * width) // x2 should depend on p_innocent
                .attr("y1", p_true_innocent * height)
                .attr("y2", p_true_innocent * height);

            let falseInnocentLine = svg.append("line")
                .attr("stroke", linecolor)
                .attr("stroke-width", 10)
                .attr("x1", p_innocent * width) // x1 should depend on p_innocent
                .attr("x2", width)
                .attr("y1", p_false_innocent * height)
                .attr("y2", p_false_innocent * height);

            let verticalLine = svg.append("line")
                .attr("stroke", linecolor)
                .attr("stroke-width", 10)
                .attr("x1", p_innocent * width)
                .attr("x2", p_innocent * width)
                .attr("y1", 0)
                .attr("y2", height);

            // Define drag behavior
            let drag = d3.drag().on("drag", function (event, d) {
                // Determine which line is being dragged
                if (d === p_innocent) {
                    p_innocent = Math.min(Math.max(event.x / width, 0), 1);
                } else if (d === p_true_innocent) {
                    p_true_innocent = Math.min(Math.max(event.y / height, 0), 1);
                } else if (d === p_false_innocent) {
                    p_false_innocent = Math.min(Math.max(event.y / height, 0), 1);
                }
                update(); // Update lines based on the new values
            });

            // Drag behavior for the vertical line
            function dragVerticalLine(event) {
                p_innocent = Math.min(Math.max(event.x / width, 0), 1);
                update();
            }

            // Drag behavior for the true innocent line
            function dragTrueInnocentLine(event) {
                p_true_innocent = Math.min(Math.max(event.y / height, 0), 1);
                update();
            }

            // Drag behavior for the false innocent line
            function dragFalseInnocentLine(event) {
                p_false_innocent = Math.min(Math.max(event.y / height, 0), 1);
                update();
            }

            // Apply the drag behavior
            verticalLine.call(d3.drag().on('drag', dragVerticalLine));
            trueInnocentLine.call(d3.drag().on('drag', dragTrueInnocentLine));
            falseInnocentLine.call(d3.drag().on('drag', dragFalseInnocentLine));

            // Function to update line positions
            function update() {
                verticalLine.attr("x1", p_innocent * width)
                    .attr("x2", p_innocent * width);

                trueInnocentLine.attr("x2", p_innocent * width)
                    .attr("y1", p_true_innocent * height)
                    .attr("y2", p_true_innocent * height);

                falseInnocentLine.attr("x1", p_innocent * width)
                    .attr("y1", p_false_innocent * height)
                    .attr("y2", p_false_innocent * height);
                regionTopLeft.attr("x", 0)
                    .attr("y", 0)
                    .attr("width", p_innocent * width)
                    .attr("height", p_true_innocent * height);

                regionTopRight.attr("x", p_innocent * width)
                    .attr("y", 0)
                    .attr("width", width - p_innocent * width)
                    .attr("height", p_false_innocent * height);

                regionBottomLeft.attr("x", 0)
                    .attr("y", p_true_innocent * height)
                    .attr("width", p_innocent * width)
                    .attr("height", height - p_true_innocent * height);

                regionBottomRight.attr("x", p_innocent * width)
                    .attr("y", p_false_innocent * height)
                    .attr("width", width - p_innocent * width)
                    .attr("height", height - p_false_innocent * height);
                textElement.text(`true positive rate = ${p_true_innocent.toFixed(2)}, 
                              true negative rate = ${(1 - p_false_innocent).toFixed(2)}, 
                              calibration = ${((p_true_innocent * p_innocent) / (p_true_innocent * p_innocent + p_false_innocent * (1 - p_innocent))).toFixed(2)}`);
            }

            update(); // Initial update of lines

            return svg.node();
        }
        squareSVG(0.6, 0.8, 0.2);
    </script>

</body>

</html>