---
title: "Notes on Using Linux"
author: "Yuxi Liu"
date: "2022-12-10"
date-modified: "2023-12-10"
categories: [programming]

format:
  html:
    toc: true
description: "My quick reference for using Linux for doing things."
image: "figure/banner_1.png"

status: "wip"
confidence: "log"
importance: 2
---

This is my quick reference for using Linux for doing things. I claim no originality. Mostly they are copy pasted from the internet and tested by me. An increasing proportion of those are produced by AI.

## Linux koans {#sec-koans}

Everything is ~~a file~~ ~~a file or a directory~~ an inode. An inode (index node) is a representation of a sequence of data that the system can access. A file is just a list of inodes, and a directory is just a list of files.

Every command is an executable.

Every machine is a server. Some merely serve extremely slow machines (humans, aka "users").

The `\usr` is not the user. It is the **U**NIX **S**ystem **R**esources.

The `\usr` was the user, until Unix became so large that `\bin` that `\bin` overflowed and had to put the rest of them in `\usr\bin`. This was embarrassing for all involved, so they moved user files to `\home`, and pretend that `\usr` stands for UNIX System Resources. ([here](http://lists.busybox.net/pipermail/busybox/2010-December/074114.html)). A mistake that only took 40 years to fix.

In the beginning was the command line. The command line is just a face of the shell. What was the original face of the command line before the shell was born?

The shell reads in a stream of letters in real time, because the user is just another file (a streaming file, named `stdin`). Like all streaming files, the user is eternal and inexhaustible. The shell stands, rapt in attention, afore the user file. 

So when does the user ever leave? The user never leaves. The shell simply kills itself when the user types `exit`. The shell would rather die than to face the prospect of reading the last word from the user.

So when does the shell ever break out of its rapt attention? Whenever it sees `\n`, it is shaken out of its trance and interprets what the user has just said, in the interval bracketed between two `\n`s.

The shell has one ear and two mouths. The ear is `stdin`, and the mouths are `stdout` and `stderr`. The shell has a tiny brain which is only capable of interpreting [the few syntactic elements of bash scripts](https://learnxinyminutes.com/docs/bash/). Everything else it wants to do, it dutifully sends a binary message into the oracular altar of the Linux kernel, from which an oceanic voice replies the answer of the kernel.

## How to `PATH` {#sec-path}

The `PATH` environment variable is a list of directories that the shell searches for commands. It is a colon-separated list of directories. For example, just about every Linux installation has a `PATH` variable that looks like:

```bash
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

To add things to `PATH`, use the `export` command, like `export PATH="$HOME/bin:$PATH"`.

## How to directories

Based on <https://askubuntu.com/a/135679>, <https://serverfault.com/a/24525>, `man hier`, [Filesystem Hierarchy Standard - Wikipedia](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard).

### Where to install read-only things

* `/bin` and `/sbin`: binaries and superuser-binaries.

* `/usr`: System-wide, read-only files installed by the OS. This directory can be remotely mounted to multiple hosts safely.
* `/usr/local`: System-wide, read-only files installed by `root`. _And that's why most directory names from `/usr` are duplicated here_.
* `/opt` - System-wide, read-only _and bundled-up_ software. That is, software that does not split their files over `bin`, `lib`, `share`, `include` like well-behaved software should.
* `/usr/bin` and `usr/sbin`: They no longer exist. Just use `/bin` and `/sbin`.

* `~/.local`: the per-user counterpart of `/usr/local`, that is: software installed by (and for) each user. Like `/usr`, it has its own `~/.local/share`, `~/.local/bin`, `~/.local/lib`.
* `~/.local/opt`: The per-user counterpart of `/opt`

Requiem for `/usr/bin` and `/usr/sbin`: Originally, `/bin` and `/lib` are only for binaries and libraries _required for booting_, while `/usr/bin` and `/usr/lib` are for all the other executables and libraries. This is no longer true, as some binaries required for booting has over the years leaked into those two folders (if there is a way to make a mess, people will make it), so since Ubuntu 20.04, they no longer exist, to remove this mess.

How to install for local user only:

```bash
./configure --prefix=$HOME/.local
make
make install
```

How to install for everyone: `sudo ./configure && make && make install`

### Where to install read-write things

Read-write things are typically configuration files, since they are read and written by both the user and binary executables.

* `/etc`: System-wide configuration. Typically used by the OS to decide what to do when starting up, shutting down, etc.
* `~/.config`: Per-user configuration files. Although because of legacy, you keep seeing nonsense like `.bashrc` in your home directory instead of `~/.config/.bashrc`. Here `rc` means "run configuration".

### Where to do read-write things

* `/home/username`, or just `~`: Each user typically is only able to modify their own folder here, like `~/myfile.txt`.
* `/tmp`: If you need to create something just for the moment, then make it here. It will be deleted when the system restarts.

### Other things (you should not modify them)

* `/run:` **run**time temporary data, representing the system's state since the last boot. It's used for storing process IDs, lock files, and other files that are would normally be stored in `/tmp`. It is basically `/tmp` for the machine.
* `/var`: Variable data. It is somewhat like `/run` in that both are meant to be read-written by programs, but unlike `/run`, data here persists over reboots. This is often used for logging information. For example, try `vim /var/log/user.log`

::: callout-warning
Modifying anything below this line may brick the system. Reading is fine though.
:::

* `/lib`: **lib**raries. You should not handle it directly. Some libraries are added at OS installation, and others at program installation. If you have a broken installation, you might be asked to manually copy some files looking like `libxxx.so` here. (`so` stands for "shared object".)
* `/boot`: Files required for **booting**. For example, the bootloader, the kernel, the initramfs (initial RAM file system).
* `/dev`: **Device** files. It typically looks like `/dev/sda1`, `/dev/sda2`, etc. Other than things like `sda1` (for harddrive) you might notice `tty1` and `pty1`' which stand for "teletype" and "pseudo teletype", respectively, but they are actually used as files to read whatever the user is typing from (the user is a file, see @sec-koans). There are some odd ones like:
  *  `/dev/null`, which is a "file" that you write to when you just want to throw something away (everything is a file, even a black hole...). 
  *  `/dev/urandom`, which is a random number generator. It is preferred over `/dev/random`. See [here](https://www.2uo.de/myths-about-urandom/#orthodoxy).
  *  `/dev/zero`, which is a file that you can't write to, but you can read, but it's filled with zeros.
* `/media`: Mount removable **medias**, like USB drives and SD cards. For example, you can mount a USB at `/media/usb1` and another one at `/media/usb2`. Mounting is typically done automatically by the system when you plug it in.
* `/mnt`: **Mounts** that are not so easily removable, like a hard drive, or a network drive. And unlike `/media`, mounting and unmounting is not automatic. On WSL, this typically has just one important thing: `/mnt/c`.
* `/srv`: Static files that are **served** out. `/srv/http` would be for static websites, `/srv/ftp` for an FTP server. It is usually used only on webservers, not an end-user machine like your laptop.

## Environment variables

### How to control them

Use `echo $X` to see what the current value of `X` is.

For current session, use `export` like `export EDITOR=nano`.

For all sessions, add to your `.bashrc` or `.profile`. If you just want to add it to the end (not recommended, as you can end up with an archeological [tell](https://en.wikipedia.org/wiki/Tell_(archaeology))), you can do one-liner like `echo "export EDITOR=nano" >> ~/.bashrc`.

### Common ones

* `PATH`: path to binaries. See @sec-path.
* `EDITOR`: default editor.
* `SHELL`: default shell.
* `HOME`: home directory.
* `USER`: current user.
* `PS1`: current prompt (just try `echo $PS1` if it doesn't make sense).

You can change prompts in a rather arcane language. For example, try this one:

```bash
export PS1="\[\e]0;\w\a\]\n\[\e[32m\]\u@\h \[\e[33m\]\w\[\e[0m\]\n\\$ "
```

## Cron jobs

Cron jobs are scheduled tasks that run periodically. For scheduling one-off tasks, use the `at` command. The name came from "Cronos", the name of the Greek god of time. A good reference is [Newbie: Intro to cron](http://www.unixgeeks.org/security/newbie/unix/cron-1.html).

### Quick reference

The cron job syntax is as follows (See [Crontab.guru - The cron schedule expression editor](https://web.archive.org/web/20231205205101/https://crontab.guru/)):

```
# ┌───────────── minute (0–59)
# │ ┌───────────── hour (0–23)
# │ │ ┌───────────── day of the month (1–31)
# │ │ │ ┌───────────── month (1–12)
# │ │ │ │ ┌───────────── day of the week (0–6) (Sunday to Saturday)
# │ │ │ │ │                                   
# │ │ │ │ │
# │ │ │ │ │
# * * * * * <command to execute>

* * * * * <once a minute>
0 * * * * <once an hour at 0-th minute>
0 0 * * * <once a day at midnight>
0 0 1 * * <once a month at the midnight of the 1-th day>
0 0 1 1 * <once a year at the midnight of January 1>
* * * * 0 <once a minute every Sunday>
```

Check that `cron` service is running by ` systemctl list-unit-files --type=service | grep "cron"`

List cron jobs by `crontab -l`.

### Creating a Cron Job

For this example, we create a job that runs every 20 seconds.

1. **Open Crontab**: 
   Open your crontab file by typing `crontab -e` in your terminal. This command opens the crontab file for the current user in the default text editor.

2. **Write Cron Job**: 
   Standard cron jobs can't run in a smaller granularity than a minute. For a once-per-20-seconds job, you'll need to use a workaround.

   Add the following lines to your crontab:

  ```bash
   * * * * * /path/to/script.sh
   * * * * * sleep 20; ~/cronjobs/script.sh
   * * * * * sleep 40; ~/cronjobs/script.sh
  ```

3. **Script Content**: 
   Create `script.sh`, have the following content:

  ```bash
  #!/bin/bash
  CRON_MESSAGE="Some message"
  echo "The cron message is: $CRON_MESSAGE"
  ```

  Then save and close the file, and `chmod +x ~/cronjobs/script.sh` to make it executable.

### Best Practices

- **Location**: Store scripts in a dedicated directory, such as `~/cronjobs`, for better organization.
- **Script Naming**: Use meaningful names for your scripts for easier identification.
- **Logging**: Implement logging within your scripts to capture output and errors for later review. It's good practice to use `/var/log/cron` for logging.

### Cron environment variables

Cron jobs run in a minimal environment, so any environment variable, like `CRON_MESSAGE`, is not accessible by the cron script. Instead, you have a few choices:

1. Put it directly in the crontab file:

```bash
CRON_MESSAGE="Some message"
* * * * * /path/to/script.sh
```

2. Put it directly in the script:

```bash
#!/bin/bash
export CRON_MESSAGE="Some message"
# rest of the script follows
```

3. If the variable is defined in an external file (like ~/.bashrc, ~/.profile, or a custom configuration file), you can source that file at the beginning of your script:

```bash
#!/bin/bash
source /path/to/environment_variables_file
# rest of the script follows
```

### Troubleshooting

- **Check Permissions**: Ensure your script is executable and the cron daemon has the necessary permissions to run it.
- **Logs**: Check `/var/log/cron` or relevant logs for errors.

If you're using WSL, ensure that the cron service is running since it doesn't start by default. Use `sudo service cron start`. You can configure `~/.bashrc` by adding the following line: `sudo service cron start`, but it would make you enter the password at every login.

Alternatively, enable `systemd` as described at @sec-init-vs-systemd.

## How to WSL

### `init` vs `systemd` {#sec-init-vs-systemd}

Every Linux starts its first process with some root process. The `init` is the traditional and simpler one, and `systemd` is more modern and advanced one.

WSL by default starts with `init` instead of `systemd`, perhaps to save time and compute. This makes things annoying for some users. You can check by `ps -p 1 -o comm` and see what it returns.

To enable `systemd`, enter in your `/etc/wsl.conf` with:

```
[boot]
systemd=true
```

or just use `cat "[boot]\nsystemd=true" >> /etc/wsl.conf`.


## Input-output

General references
* [The TTY demystified](https://www.linusakesson.net/programming/tty/)
* [command line - Why is a virtual terminal "virtual", and what/why/where is the "real" terminal? - Ask Ubuntu](https://askubuntu.com/questions/14284/why-is-a-virtual-terminal-virtual-and-what-why-where-is-the-real-terminal)
* [What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'? - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con)

There are in general three forms of input-output that a Linux system deals with: local processes, local user, remote/networked. In all cases, because everything is a file, it is a matter of designing the right kind of input-output file. For input-output, the system creates and reads/writes from device files.

There are three kinds of device files: character, block, and fifo (named pipes). The character file is character-by-character, the block file is block-by-block, where the block size is variable, and the fifo does not have a fixed block size.

The fifo is usually used by a program to communicate with another program. One can think of it as a message system built for programs. One program needs to send some data to another program, and the other program needs to receive it, so the first writes up some data in a long scroll of text and deposits it into a mail box. Then the other program comes along and pulls on the output end of the mail box. Out comes some of the scroll! The second program reads it and remembers it, since the scroll disintegrates into aether as soon as it touches the air...

## Console, terminal, teletypes, and pseudoteletypes

### Console

In the long past, a "console" was a piece of desk-like furniture. It looks like a small piano. You sit in front of it and put some small items on top of the "piano keyboard". This word was then borrowed into pipe organs, where you sit at the "console" and play the many buttons. Then this was borrowed into computer engineering, because computer consoles looked like organ consoles.

[![Arles (Bouches-du-Rhône, Provence, France), in the former grand priory of the Knights of Malta, the collections of the Réattu museum. Louis XIV style console.](figure/R%C3%A9attu39_console_style_Louis_XIV.jpg)](https://commons.wikimedia.org/wiki/File:R%C3%A9attu39_console_style_Louis_XIV.jpg)

[![Console of an organ built in 1912.](figure/Pipe.organ.console.arp.jpg)](https://en.wikipedia.org/wiki/File:Pipe.organ.console.arp.jpg)

[![IBM 1620 Model 1 Console](figure/IBM_1620_Model_1.jpg)](https://en.wiktionary.org/wiki/File:IBM_1620_Model_1.jpg)

### Terminal

A "terminal" is a term borrowed from electric engineering. In an electric circuit, you would break the circuit into pieces. each piece contains some internal elements, and then there are those dangling pieces that are free to be connected to other circuits. Those dangling pieces are the terminals. In analogy, the place where a computer-user was sitting at became called the "computer terminal", or just the "terminal". What are they the "terminals" of? They are the terminals of what is "internal" -- the giant computer, sitting loudly at the center of the electric engineering building.

### Teletypes

Computers used to only allow inputs via magnetic tapes, and other forms of raw binaries, and outputs via printing on a printer. This is not interactive for humans, so they were then wired to typewriters. The human sits and types on the keyboard. An electric representation of whatever is typed was stored in a local "buffer" (something like a row of flip-flops would do just fine). When the user presses "enter", the buffer is read out and sent down the electric wire to the computer. The machine whirls, computes the output, then sends it back to the electromechanical controller of the typewriter, which prints it on the paper. This is the "teletype" (tele-typewriter -- they had a thing for the prefix "tele-").

There are two possible ways to deal with the user's input. What I described above is that the user sends in inputs one line at a time (block mode, or for this case, line mode). The other way is to send one character at a time (character mode). Both have their uses and ended up in modern Linux systems.

With the teletype-computer setup, we are basically 90\% way to the modern setup. The remaining 10\% comes from just making this setup more user-friendly. Let's see how we can try to add little conveniences, and end up with the modern setup.

The most basic convenience would be the ability to delete characters. Unfortunately, as you know, you can't rub out what is written, not on paper.

> The Moving Finger writes; and, having writ, Moves on: nor all thy Piety nor Wit Shall lure it back to cancel half a Line, Nor all thy Tears wash out a Word of it. ― Omar Khayyám

The obvious solution is to use an electronic monitor -- a cathode-ray tube. It is expensive, but if you can afford one, then it's trivial to delete characters. Just press the `backspace` and the character will disappear. With the adoption of the `backspace`, it is natural to use the line mode. You would do something like `login<BS><BS>off<enter>`, and the computer would receive just `logoff<enter>`.

The next convenience would be autocompletion. If you type `ls /et<tab>`, you would get `ls /etc/`. Now, the terminal, dissociated from the computer, has no way to know how to autocomplete it. Only the computer knows what the file system looks like, so only the computer can know that the only directory that starts with `/et` is `/etc/`. And so, to get autocompletion, we need to have the terminal and the computer communicate with each other in the middle of a line.

Now, you might suggest that we can just make `<tab>` send in the line buffer, just like `<enter>`. However, what if you want to do editing with something like `vi`? Then you would like to send every letter directly to the computer. If you have an active search, then keep pressing `n`, the screen must jump to the next search-match every time you press `n`, without waiting for you to press `<tab>` or `<enter>`. 

So, the natural thing to do is to switch to character mode. The computer would run a dedicated process that listens for every character sent by the teletype, as the interface between the teletype and the operating system.

As time goes on, the electronic displays are upgraded every year, but rewriting the code for displaying is too annoying. Well, nothing solves a problem like an extra layer of redirection/API. So they created a layer between the physical display device and the OS, called the "virtual terminal". Now the OS just needs to talk to the physical terminal in the language of the "virtual terminal", and the physical terminal is responsible to translate that into physically real display. The same for inputs -- the user types, the terminal translates it into virtual terminal inputs, and the OS processes those.

Later, even the manufacturers of the physical terminal got tired of rewriting the hard-coded logic, and they also noticed that the digital logic chips are getting so cheap that they can afford to put a few in their "dumb" terminals, and that their users wanted to use the old model instead of the new one, so... one more layer of indirection! They added small chips inside the terminal (not so "dumb" anymore), which would run a "terminal emulator" program to allow users to use the new model as if it's the old model. For example, if the terminal is a VT240, but the user really wants to use VT100. Well, the user just has to select the `VT100 mode` on the terminal. Then, the terminal emulator would translate the virtual terminal into the pixels on the screen, VT100-style. Otherwise, the terminal emulator would do the translation, VT240-style.

### Echos

Once we have a separation between the terminal and the main computer it is connected to, the problem of "echo" appears. In the long past, pressing a button on a typewriter immediately creates a letter on the paper. You could say that it is a "mechanical echo", but that's really stretching it. Then, with teletypes, we type on a mechanical typewriter, and whatever is typed gets "echoed" to the paper as before, and a copy is sent to the distant computer. But then, one teletype was cut in two: the keyboard half and the paper-printing half. You type on the keyboard; the key is converted to an electric signal to the computer; the computer reads it and has to make a programmable decision to `echo` what you sent in to the output printer. The computer could just echo back verbatim, or it could allow you to delete letters and retype, and echo back a full line once you press "enter".

With electronic terminals replacing the mechanical ones, the echo could once again move to the terminal itself. Want to delete a character? Press backspace and it disappears from the screen! The entire line is sent to the computer once you press enter. In other words, `echo` became "local" again. What changed? What changed is that after this process of moving `echo` away, then back to the terminal, the `echo` concept has arisen to the class consciousness of the computing intelligentsia.[^marxist-consciousness]

[^marxist-consciousness]: I did not set out to write something that smells like Marxist historiography, but so be it.

With the rise of computer networks, the decision to echo, and where to echo, became a careful design choice. For example, `Telnet` has 5 echo modes[^telnet-echo]:

[^telnet-echo]: Figure from [RFC 857: Telnet Echo Option](https://www.rfc-editor.org/rfc/rfc857.html)

```
                <----------------
      Process 1                   Process 2
                ---------------->
                 Neither end echoes


                <----------------
                   \
      Process 1    /              Process 2
                ---------------->
             One end echoes for itself
                <----------------
                             \
      Process 1              /    Process 2
                ---------------->
          One end echoes for the other


                <----------------
                   \         /
      Process 1    /         \    Process 2
                ---------------->
          Both ends echo for themselves


                <----------------
                   \ /
      Process 1    / \            Process 2
                ---------------->
           One end echoes for both ends
```

### Pseudo-teletypes

Our journey is almost complete. One last thing: pseudo-teletypes.

A pseudo-teletype (pty) in some way closes the circle: if every user is a process that generates a file, then every process is... a user. So, if users can use a teletype, then processes can also use teletypes. For security reasons, Unix-like operating systems have two levels of privileges for processes. There are those that are in "user space" and there are those in "kernel space". Everything in "kernel space" has the same powers of messing things up as the actual OS, and must be carefully protected. In particular, processes in kernel space are fully capable of blanketing the hard drive with zeroes, covering the terminal screen with flashing lights, etc. So, by default, processes are run in user space.

Now, recalling back to their origins, a teletype is a physical machine. A virtual terminal is an API to a physical machine. It stands to reason that `tty`, which are device files for physical machines, are read-written by processes in kernel space. So, what can processes in user space do? One more layer of indirection.

Instead of running the `tty`, they use `pty`, which stands for "pseudo-teletype". They are files with similar format as `tty`, but run in user space. By using those `pty`s, programs that used to interface with the `tty` can now be just plugged to a `pty` and function as if they were connected to the `tty`.

This gets up to how modern Linux systems work. At start up, they spawn several `tty`. Most of them remain unused. One of them (usually `tty7`) is plugged to a user interface (command-line or graphical). Then, like a hydra, out of the single `tty7` are spawned as many `pty` as needed, all of them funneled through the single `tty7`. If you open a new terminal window, you get a new `pty`. If you close it, that `pty` is also closed. Processes can spawn multiple `pty` to communicate with other processes.I can imagine an old process down there behind `tty7` thinking "That user types really fast...".
